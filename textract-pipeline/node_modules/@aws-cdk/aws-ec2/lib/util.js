"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cdk = require("@aws-cdk/cdk");
const vpc_1 = require("./vpc");
const vpc_ref_1 = require("./vpc-ref");
/**
 * Turn an arbitrary string into one that can be used as a CloudFormation identifier by stripping special characters
 *
 * (At the moment, no efforts are taken to prevent collissions, but we can add that later when it becomes necessary).
 */
function slugify(x) {
    return x.replace(/[^a-zA-Z0-9]/g, '');
}
exports.slugify = slugify;
/**
 * The default names for every subnet type
 */
exports.DEFAULT_SUBNET_NAME = {
    [vpc_ref_1.SubnetType.Public]: 'Public',
    [vpc_ref_1.SubnetType.Private]: 'Private',
    [vpc_ref_1.SubnetType.Isolated]: 'Isolated',
};
/**
 * Return a subnet name from its construct ID
 *
 * All subnet names look like NAME <> "Subnet" <> INDEX
 */
function subnetName(subnet) {
    return subnet.node.id.replace(/Subnet\d+$/, '');
}
exports.subnetName = subnetName;
/**
 * Make the subnet construct ID from a name and number
 */
function subnetId(name, i) {
    return `${name}Subnet${i + 1}`;
}
exports.subnetId = subnetId;
/**
 * Helper class to export/import groups of subnets
 */
class ExportSubnetGroup {
    constructor(scope, exportName, subnets, type, azs) {
        this.subnets = subnets;
        this.type = type;
        this.azs = azs;
        this.groups = subnets.length / azs;
        // ASSERTION
        if (Math.floor(this.groups) !== this.groups) {
            throw new Error(`Number of subnets (${subnets.length}) must be a multiple of number of availability zones (${azs})`);
        }
        this.ids = this.exportIds(scope, exportName);
        this.names = this.exportNames();
    }
    exportIds(scope, name) {
        if (this.subnets.length === 0) {
            return undefined;
        }
        return new cdk.StringListCfnOutput(scope, name, { values: this.subnets.map(s => s.subnetId) }).makeImportValues().map(x => x.toString());
    }
    /**
     * Return the list of subnet names if they're not equal to the default
     */
    exportNames() {
        if (this.subnets.length === 0) {
            return undefined;
        }
        const netNames = this.subnets.map(subnetName);
        // Do some assertion that the 'netNames' array is laid out like this:
        //
        // [ INGRESS, INGRESS, INGRESS, EGRESS, EGRESS, EGRESS, ... ]
        for (let i = 0; i < netNames.length; i++) {
            const k = Math.floor(i / this.azs);
            if (netNames[i] !== netNames[k * this.azs]) {
                throw new Error(`Subnets must be grouped by name, got: ${JSON.stringify(netNames)}`);
            }
        }
        // Splat down to [ INGRESS, EGRESS, ... ]
        const groupNames = range(this.groups).map(i => netNames[i * this.azs]);
        if (groupNames.length === 1 && groupNames[0] === exports.DEFAULT_SUBNET_NAME[this.type]) {
            return undefined;
        }
        return groupNames;
    }
}
exports.ExportSubnetGroup = ExportSubnetGroup;
class ImportSubnetGroup {
    constructor(subnetIds, names, type, availabilityZones, idField, nameField) {
        this.availabilityZones = availabilityZones;
        this.subnetIds = subnetIds || [];
        this.groups = this.subnetIds.length / this.availabilityZones.length;
        if (Math.floor(this.groups) !== this.groups) {
            // tslint:disable-next-line:max-line-length
            throw new Error(`Amount of ${idField} (${this.subnetIds.length}) must be a multiple of availability zones (${this.availabilityZones.length}).`);
        }
        this.names = this.normalizeNames(names, exports.DEFAULT_SUBNET_NAME[type], nameField);
    }
    import(scope) {
        return range(this.subnetIds.length).map(i => {
            const k = Math.floor(i / this.availabilityZones.length);
            return vpc_1.VpcSubnet.import(scope, subnetId(this.names[k], i), {
                availabilityZone: this.pickAZ(i),
                subnetId: this.subnetIds[i]
            });
        });
    }
    /**
     * Return a list with a name for every subnet
     */
    normalizeNames(names, defaultName, fieldName) {
        // If not given, return default
        if (names === undefined || names.length === 0) {
            return [defaultName];
        }
        // If given, must match given subnets
        if (names.length !== this.groups) {
            throw new Error(`${fieldName} must have an entry for every corresponding subnet group, got: ${JSON.stringify(names)}`);
        }
        return names;
    }
    /**
     * Return the i'th AZ
     */
    pickAZ(i) {
        return this.availabilityZones[i % this.availabilityZones.length];
    }
}
exports.ImportSubnetGroup = ImportSubnetGroup;
/**
 * Generate the list of numbers of [0..n)
 */
function range(n) {
    const ret = [];
    for (let i = 0; i < n; i++) {
        ret.push(i);
    }
    return ret;
}
exports.range = range;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxvQ0FBcUM7QUFDckMsK0JBQWtDO0FBQ2xDLHVDQUFtRDtBQUVuRDs7OztHQUlHO0FBQ0gsU0FBZ0IsT0FBTyxDQUFDLENBQVM7SUFDL0IsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBRkQsMEJBRUM7QUFFRDs7R0FFRztBQUNVLFFBQUEsbUJBQW1CLEdBQUc7SUFDakMsQ0FBQyxvQkFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLFFBQVE7SUFDN0IsQ0FBQyxvQkFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFLFNBQVM7SUFDL0IsQ0FBQyxvQkFBVSxDQUFDLFFBQVEsQ0FBQyxFQUFFLFVBQVU7Q0FDbEMsQ0FBQztBQUVGOzs7O0dBSUc7QUFDSCxTQUFnQixVQUFVLENBQUMsTUFBa0I7SUFDM0MsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFGRCxnQ0FFQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsUUFBUSxDQUFDLElBQVksRUFBRSxDQUFTO0lBQzlDLE9BQU8sR0FBRyxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO0FBQ2pDLENBQUM7QUFGRCw0QkFFQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxpQkFBaUI7SUFNNUIsWUFDSSxLQUFvQixFQUNwQixVQUFrQixFQUNELE9BQXFCLEVBQ3JCLElBQWdCLEVBQ2hCLEdBQVc7UUFGWCxZQUFPLEdBQVAsT0FBTyxDQUFjO1FBQ3JCLFNBQUksR0FBSixJQUFJLENBQVk7UUFDaEIsUUFBRyxHQUFILEdBQUcsQ0FBUTtRQUU5QixJQUFJLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFD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LEtBQUssQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsU0FBUyxrRUFBa0UsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDeEg7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNLLE1BQU0sQ0FBQyxDQUFTO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkUsQ0FBQztDQUNGO0FBekRELDhDQXlEQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsS0FBSyxDQUFDLENBQVM7SUFDN0IsTUFBTSxHQUFHLEdBQWEsRUFBRSxDQUFDO0lBQ3pCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDMUIsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNiO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBTkQsc0JBTUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2RrID0gcmVxdWlyZSgnQGF3cy1jZGsvY2RrJyk7XG5pbXBvcnQgeyBWcGNTdWJuZXQgfSBmcm9tICcuL3ZwYyc7XG5pbXBvcnQgeyBJVnBjU3VibmV0LCBTdWJuZXRUeXBlIH0gZnJvbSBcIi4vdnBjLXJlZlwiO1xuXG4vKipcbiAqIFR1cm4gYW4gYXJiaXRyYXJ5IHN0cmluZyBpbnRvIG9uZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgQ2xvdWRGb3JtYXRpb24gaWRlbnRpZmllciBieSBzdHJpcHBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gKlxuICogKEF0IHRoZSBtb21lbnQsIG5vIGVmZm9ydHMgYXJlIHRha2VuIHRvIHByZXZlbnQgY29sbGlzc2lvbnMsIGJ1dCB3ZSBjYW4gYWRkIHRoYXQgbGF0ZXIgd2hlbiBpdCBiZWNvbWVzIG5lY2Vzc2FyeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbHVnaWZ5KHg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB4LnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnJyk7XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgbmFtZXMgZm9yIGV2ZXJ5IHN1Ym5ldCB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NVQk5FVF9OQU1FID0ge1xuICBbU3VibmV0VHlwZS5QdWJsaWNdOiAnUHVibGljJyxcbiAgW1N1Ym5ldFR5cGUuUHJpdmF0ZV06ICdQcml2YXRlJyxcbiAgW1N1Ym5ldFR5cGUuSXNvbGF0ZWRdOiAnSXNvbGF0ZWQnLFxufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdWJuZXQgbmFtZSBmcm9tIGl0cyBjb25zdHJ1Y3QgSURcbiAqXG4gKiBBbGwgc3VibmV0IG5hbWVzIGxvb2sgbGlrZSBOQU1FIDw+IFwiU3VibmV0XCIgPD4gSU5ERVhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1Ym5ldE5hbWUoc3VibmV0OiBJVnBjU3VibmV0KSB7XG4gIHJldHVybiBzdWJuZXQubm9kZS5pZC5yZXBsYWNlKC9TdWJuZXRcXGQrJC8sICcnKTtcbn1cblxuLyoqXG4gKiBNYWtlIHRoZSBzdWJuZXQgY29uc3RydWN0IElEIGZyb20gYSBuYW1lIGFuZCBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1Ym5ldElkKG5hbWU6IHN0cmluZywgaTogbnVtYmVyKSB7XG4gIHJldHVybiBgJHtuYW1lfVN1Ym5ldCR7aSArIDF9YDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gZXhwb3J0L2ltcG9ydCBncm91cHMgb2Ygc3VibmV0c1xuICovXG5leHBvcnQgY2xhc3MgRXhwb3J0U3VibmV0R3JvdXAge1xuICBwdWJsaWMgcmVhZG9ubHkgaWRzPzogc3RyaW5nW107XG4gIHB1YmxpYyByZWFkb25seSBuYW1lcz86IHN0cmluZ1tdO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgZ3JvdXBzOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBzY29wZTogY2RrLkNvbnN0cnVjdCxcbiAgICAgIGV4cG9ydE5hbWU6IHN0cmluZyxcbiAgICAgIHByaXZhdGUgcmVhZG9ubHkgc3VibmV0czogSVZwY1N1Ym5ldFtdLFxuICAgICAgcHJpdmF0ZSByZWFkb25seSB0eXBlOiBTdWJuZXRUeXBlLFxuICAgICAgcHJpdmF0ZSByZWFkb25seSBhenM6IG51bWJlcikge1xuXG4gICAgdGhpcy5ncm91cHMgPSBzdWJuZXRzLmxlbmd0aCAvIGF6cztcblxuICAgIC8vIEFTU0VSVElPTlxuICAgIGlmIChNYXRoLmZsb29yKHRoaXMuZ3JvdXBzKSAhPT0gdGhpcy5ncm91cHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTnVtYmVyIG9mIHN1Ym5ldHMgKCR7c3VibmV0cy5sZW5ndGh9KSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgbnVtYmVyIG9mIGF2YWlsYWJpbGl0eSB6b25lcyAoJHthenN9KWApO1xuICAgIH1cblxuICAgIHRoaXMuaWRzID0gdGhpcy5leHBvcnRJZHMoc2NvcGUsIGV4cG9ydE5hbWUpO1xuICAgIHRoaXMubmFtZXMgPSB0aGlzLmV4cG9ydE5hbWVzKCk7XG4gIH1cblxuICBwcml2YXRlIGV4cG9ydElkcyhzY29wZTogY2RrLkNvbnN0cnVjdCwgbmFtZTogc3RyaW5nKTogc3RyaW5nW10gfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLnN1Ym5ldHMubGVuZ3RoID09PSAwKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICByZXR1cm4gbmV3IGNkay5TdHJpbmdMaXN0Q2ZuT3V0cHV0KHNjb3BlLCBuYW1lLCB7IHZhbHVlczogdGhpcy5zdWJuZXRzLm1hcChzID0+IHMuc3VibmV0SWQpIH0pLm1ha2VJbXBvcnRWYWx1ZXMoKS5tYXAoeCA9PiB4LnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGlzdCBvZiBzdWJuZXQgbmFtZXMgaWYgdGhleSdyZSBub3QgZXF1YWwgdG8gdGhlIGRlZmF1bHRcbiAgICovXG4gIHByaXZhdGUgZXhwb3J0TmFtZXMoKTogc3RyaW5nW10gfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLnN1Ym5ldHMubGVuZ3RoID09PSAwKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICBjb25zdCBuZXROYW1lcyA9IHRoaXMuc3VibmV0cy5tYXAoc3VibmV0TmFtZSk7XG5cbiAgICAvLyBEbyBzb21lIGFzc2VydGlvbiB0aGF0IHRoZSAnbmV0TmFtZXMnIGFycmF5IGlzIGxhaWQgb3V0IGxpa2UgdGhpczpcbiAgICAvL1xuICAgIC8vIFsgSU5HUkVTUywgSU5HUkVTUywgSU5HUkVTUywgRUdSRVNTLCBFR1JFU1MsIEVHUkVTUywgLi4uIF1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ldE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrID0gTWF0aC5mbG9vcihpIC8gdGhpcy5henMpO1xuICAgICAgaWYgKG5ldE5hbWVzW2ldICE9PSBuZXROYW1lc1trICogdGhpcy5henNdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3VibmV0cyBtdXN0IGJlIGdyb3VwZWQgYnkgbmFtZSwgZ290OiAke0pTT04uc3RyaW5naWZ5KG5ldE5hbWVzKX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTcGxhdCBkb3duIHRvIFsgSU5HUkVTUywgRUdSRVNTLCAuLi4gXVxuICAgIGNvbnN0IGdyb3VwTmFtZXMgPSByYW5nZSh0aGlzLmdyb3VwcykubWFwKGkgPT4gbmV0TmFtZXNbaSAqIHRoaXMuYXpzXSk7XG4gICAgaWYgKGdyb3VwTmFtZXMubGVuZ3RoID09PSAxICYmIGdyb3VwTmFtZXNbMF0gPT09IERFRkFVTFRfU1VCTkVUX05BTUVbdGhpcy50eXBlXSkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICByZXR1cm4gZ3JvdXBOYW1lcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW1wb3J0U3VibmV0R3JvdXAge1xuICBwcml2YXRlIHJlYWRvbmx5IHN1Ym5ldElkczogc3RyaW5nW107XG4gIHByaXZhdGUgcmVhZG9ubHkgbmFtZXM6IHN0cmluZ1tdO1xuICBwcml2YXRlIHJlYWRvbmx5IGdyb3VwczogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgc3VibmV0SWRzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCxcbiAgICAgIG5hbWVzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCxcbiAgICAgIHR5cGU6IFN1Ym5ldFR5cGUsXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IGF2YWlsYWJpbGl0eVpvbmVzOiBzdHJpbmdbXSxcbiAgICAgIGlkRmllbGQ6IHN0cmluZyxcbiAgICAgIG5hbWVGaWVsZDogc3RyaW5nKSB7XG5cbiAgICB0aGlzLnN1Ym5ldElkcyA9IHN1Ym5ldElkcyB8fCBbXTtcbiAgICB0aGlzLmdyb3VwcyA9IHRoaXMuc3VibmV0SWRzLmxlbmd0aCAvIHRoaXMuYXZhaWxhYmlsaXR5Wm9uZXMubGVuZ3RoO1xuXG4gICAgaWYgKE1hdGguZmxvb3IodGhpcy5ncm91cHMpICE9PSB0aGlzLmdyb3Vwcykge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbW91bnQgb2YgJHtpZEZpZWxkfSAoJHt0aGlzLnN1Ym5ldElkcy5sZW5ndGh9KSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgYXZhaWxhYmlsaXR5IHpvbmVzICgke3RoaXMuYXZhaWxhYmlsaXR5Wm9uZXMubGVuZ3RofSkuYCk7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lcyA9IHRoaXMubm9ybWFsaXplTmFtZXMobmFtZXMsIERFRkFVTFRfU1VCTkVUX05BTUVbdHlwZV0sIG5hbWVGaWVsZCk7XG4gIH1cblxuICBwdWJsaWMgaW1wb3J0KHNjb3BlOiBjZGsuQ29uc3RydWN0KTogSVZwY1N1Ym5ldFtdIHtcbiAgICByZXR1cm4gcmFuZ2UodGhpcy5zdWJuZXRJZHMubGVuZ3RoKS5tYXAoaSA9PiB7XG4gICAgICBjb25zdCBrID0gTWF0aC5mbG9vcihpIC8gdGhpcy5hdmFpbGFiaWxpdHlab25lcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIFZwY1N1Ym5ldC5pbXBvcnQoc2NvcGUsIHN1Ym5ldElkKHRoaXMubmFtZXNba10sIGkpLCB7XG4gICAgICAgIGF2YWlsYWJpbGl0eVpvbmU6IHRoaXMucGlja0FaKGkpLFxuICAgICAgICBzdWJuZXRJZDogdGhpcy5zdWJuZXRJZHNbaV1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGxpc3Qgd2l0aCBhIG5hbWUgZm9yIGV2ZXJ5IHN1Ym5ldFxuICAgKi9cbiAgcHJpdmF0ZSBub3JtYWxpemVOYW1lcyhuYW1lczogc3RyaW5nW10gfCB1bmRlZmluZWQsIGRlZmF1bHROYW1lOiBzdHJpbmcsIGZpZWxkTmFtZTogc3RyaW5nKSB7XG4gICAgLy8gSWYgbm90IGdpdmVuLCByZXR1cm4gZGVmYXVsdFxuICAgIGlmIChuYW1lcyA9PT0gdW5kZWZpbmVkIHx8IG5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtkZWZhdWx0TmFtZV07XG4gICAgfVxuXG4gICAgLy8gSWYgZ2l2ZW4sIG11c3QgbWF0Y2ggZ2l2ZW4gc3VibmV0c1xuICAgIGlmIChuYW1lcy5sZW5ndGggIT09IHRoaXMuZ3JvdXBzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGROYW1lfSBtdXN0IGhhdmUgYW4gZW50cnkgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcgc3VibmV0IGdyb3VwLCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkobmFtZXMpfWApO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGkndGggQVpcbiAgICovXG4gIHByaXZhdGUgcGlja0FaKGk6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJpbGl0eVpvbmVzW2kgJSB0aGlzLmF2YWlsYWJpbGl0eVpvbmVzLmxlbmd0aF07XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgbGlzdCBvZiBudW1iZXJzIG9mIFswLi5uKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2UobjogbnVtYmVyKTogbnVtYmVyW10ge1xuICBjb25zdCByZXQ6IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgcmV0LnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiJdfQ==