"use strict";
const fc = require("fast-check");
const _ = require("lodash");
const nodeunit = require("nodeunit");
const lib_1 = require("../lib");
function asyncTest(cb) {
    return async (test) => {
        let error;
        try {
            await cb(test);
        }
        catch (e) {
            error = e;
        }
        finally {
            test.doesNotThrow(() => {
                if (error) {
                    throw error;
                }
            });
            test.done();
        }
    };
}
const nonEmptyString = fc.string(1, 16);
const tokenish = fc.array(nonEmptyString, 2, 2).map(arr => ({ [arr[0]]: arr[1] }));
const anyValue = fc.oneof(nonEmptyString, tokenish);
function stringListToken(o) {
    return new lib_1.Token(o).toList();
}
function stringToken(o) {
    return new lib_1.Token(o).toString();
}
module.exports = nodeunit.testCase({
    FnJoin: {
        'rejects empty list of arguments to join'(test) {
            test.throws(() => lib_1.Fn.join('.', []));
            test.done();
        },
        'collapse nested FnJoins even if they contain tokens'(test) {
            const stack = new lib_1.Stack();
            const obj = lib_1.Fn.join('', [
                'a',
                lib_1.Fn.join('', [lib_1.Fn.getAtt('a', 'bc').toString(), 'c']),
                'd'
            ]);
            test.deepEqual(stack.node.resolve(obj), { 'Fn::Join': ["",
                    [
                        "a",
                        { 'Fn::GetAtt': ['a', 'bc'] },
                        'cd',
                    ]
                ] });
            test.done();
        },
        'resolves to the value if only one value is joined': asyncTest(async () => {
            const stack = new lib_1.Stack();
            await fc.assert(fc.property(fc.string(), anyValue, (delimiter, value) => _.isEqual(stack.node.resolve(lib_1.Fn.join(delimiter, [value])), value)), { verbose: true });
        }),
        'pre-concatenates string literals': asyncTest(async () => {
            const stack = new lib_1.Stack();
            await fc.assert(fc.property(fc.string(), fc.array(nonEmptyString, 1, 15), (delimiter, values) => stack.node.resolve(lib_1.Fn.join(delimiter, values)) === values.join(delimiter)), { verbose: true });
        }),
        'pre-concatenates around tokens': asyncTest(async () => {
            const stack = new lib_1.Stack();
            await fc.assert(fc.property(fc.string(), fc.array(nonEmptyString, 1, 3), tokenish, fc.array(nonEmptyString, 1, 3), (delimiter, prefix, obj, suffix) => _.isEqual(stack.node.resolve(lib_1.Fn.join(delimiter, [...prefix, stringToken(obj), ...suffix])), { 'Fn::Join': [delimiter, [prefix.join(delimiter), obj, suffix.join(delimiter)]] })), { verbose: true, seed: 1539874645005, path: "0:0:0:0:0:0:0:0:0" });
        }),
        'flattens joins nested under joins with same delimiter': asyncTest(async () => {
            const stack = new lib_1.Stack();
            await fc.assert(fc.property(fc.string(), fc.array(anyValue), fc.array(anyValue, 1, 3), fc.array(anyValue), (delimiter, prefix, nested, suffix) => 
            // Gonna test
            _.isEqual(stack.node.resolve(lib_1.Fn.join(delimiter, [...prefix, lib_1.Fn.join(delimiter, nested), ...suffix])), stack.node.resolve(lib_1.Fn.join(delimiter, [...prefix, ...nested, ...suffix])))), { verbose: true });
        }),
        'does not flatten joins nested under joins with different delimiter': asyncTest(async () => {
            const stack = new lib_1.Stack();
            await fc.assert(fc.property(fc.string(), fc.string(), fc.array(anyValue, 1, 3), fc.array(tokenish, 2, 3), fc.array(anyValue, 3), (delimiter1, delimiter2, prefix, nested, suffix) => {
                fc.pre(delimiter1 !== delimiter2);
                const join = lib_1.Fn.join(delimiter1, [...prefix, lib_1.Fn.join(delimiter2, stringListToken(nested)), ...suffix]);
                const resolved = stack.node.resolve(join);
                return resolved['Fn::Join'][1].find((e) => typeof e === 'object'
                    && ('Fn::Join' in e)
                    && e['Fn::Join'][0] === delimiter2) != null;
            }), { verbose: true });
        }),
    },
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5mbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRlc3QuZm4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLGlDQUFrQztBQUNsQyw0QkFBNkI7QUFDN0IscUNBQXNDO0FBQ3RDLGdDQUEwQztBQUUxQyxTQUFTLFNBQVMsQ0FBQyxFQUEwQztJQUMzRCxPQUFPLEtBQUssRUFBRSxJQUFtQixFQUFFLEVBQUU7UUFDbkMsSUFBSSxLQUFZLENBQUM7UUFDakIsSUFBSTtZQUNGLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2hCO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixLQUFLLEdBQUcsQ0FBQyxDQUFDO1NBQ1g7Z0JBQVM7WUFDUixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRTtnQkFDckIsSUFBSSxLQUFLLEVBQUU7b0JBQUUsTUFBTSxLQUFLLENBQUM7aUJBQUU7WUFDN0IsQ0FBQyxDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDYjtJQUNILENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLGNBQWMsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUN4QyxNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ25GLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQU0sY0FBYyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBaUd6RCxTQUFTLGVBQWUsQ0FBQyxDQUFNO0lBQzdCLE9BQU8sSUFBSSxXQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFB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QUFNLEVBQUUsUUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO2dCQUN2RyxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDMUMsT0FBTyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBTSxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxRQUFRO3VCQUN0QixDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUM7dUJBQ2pCLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxVQUFVLENBQUMsSUFBSSxJQUFJLENBQUM7WUFDMUYsQ0FBQyxDQUNGLEVBQ0QsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQ2xCLENBQUM7UUFDSixDQUFDLENBQUM7S0FDSDtDQUNGLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmYyA9IHJlcXVpcmUoJ2Zhc3QtY2hlY2snKTtcbmltcG9ydCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5pbXBvcnQgbm9kZXVuaXQgPSByZXF1aXJlKCdub2RldW5pdCcpO1xuaW1wb3J0IHsgRm4sIFN0YWNrLCBUb2tlbiB9IGZyb20gJy4uL2xpYic7XG5cbmZ1bmN0aW9uIGFzeW5jVGVzdChjYjogKHRlc3Q6IG5vZGV1bml0LlRlc3QpID0+IFByb21pc2U8dm9pZD4pOiAodGVzdDogbm9kZXVuaXQuVGVzdCkgPT4gdm9pZCB7XG4gIHJldHVybiBhc3luYyAodGVzdDogbm9kZXVuaXQuVGVzdCkgPT4ge1xuICAgIGxldCBlcnJvcjogRXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNiKHRlc3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGVzdC5kb2VzTm90VGhyb3coKCkgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHsgdGhyb3cgZXJyb3I7IH1cbiAgICAgIH0pO1xuICAgICAgdGVzdC5kb25lKCk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBub25FbXB0eVN0cmluZyA9IGZjLnN0cmluZygxLCAxNik7XG5jb25zdCB0b2tlbmlzaCA9IGZjLmFycmF5KG5vbkVtcHR5U3RyaW5nLCAyLCAyKS5tYXAoYXJyID0+ICh7IFthcnJbMF1dOiBhcnJbMV0gfSkpO1xuY29uc3QgYW55VmFsdWUgPSBmYy5vbmVvZjxhbnk+KG5vbkVtcHR5U3RyaW5nLCB0b2tlbmlzaCk7XG5cbmV4cG9ydCA9IG5vZGV1bml0LnRlc3RDYXNlKHtcbiAgRm5Kb2luOiB7XG4gICAgJ3JlamVjdHMgZW1wdHkgbGlzdCBvZiBhcmd1bWVudHMgdG8gam9pbicodGVzdDogbm9kZXVuaXQuVGVzdCkge1xuICAgICAgdGVzdC50aHJvd3MoKCkgPT4gRm4uam9pbignLicsIFtdKSk7XG4gICAgICB0ZXN0LmRvbmUoKTtcbiAgICB9LFxuICAgICdjb2xsYXBzZSBuZXN0ZWQgRm5Kb2lucyBldmVuIGlmIHRoZXkgY29udGFpbiB0b2tlbnMnKHRlc3Q6IG5vZGV1bml0LlRlc3QpIHtcbiAgICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG5cbiAgICAgIGNvbnN0IG9iaiA9IEZuLmpvaW4oJycsIFtcbiAgICAgICAgJ2EnLFxuICAgICAgICBGbi5qb2luKCcnLCBbRm4uZ2V0QXR0KCdhJywgJ2JjJykudG9TdHJpbmcoKSwgJ2MnXSksXG4gICAgICAgICdkJ1xuICAgICAgXSk7XG5cbiAgICAgIHRlc3QuZGVlcEVxdWFsKHN0YWNrLm5vZGUucmVzb2x2ZShvYmopLCB7ICdGbjo6Sm9pbic6IFsgXCJcIixcbiAgICAgICAgW1xuICAgICAgICAgIFwiYVwiLFxuICAgICAgICAgIHsgJ0ZuOjpHZXRBdHQnOiBbJ2EnLCAnYmMnXSB9LFxuICAgICAgICAgICdjZCcsXG4gICAgICAgIF1cbiAgICAgIF19KTtcblxuICAgICAgdGVzdC5kb25lKCk7XG4gICAgfSxcbiAgICAncmVzb2x2ZXMgdG8gdGhlIHZhbHVlIGlmIG9ubHkgb25lIHZhbHVlIGlzIGpvaW5lZCc6IGFzeW5jVGVzdChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5zdHJpbmcoKSwgYW55VmFsdWUsXG4gICAgICAgICAgKGRlbGltaXRlciwgdmFsdWUpID0+IF8uaXNFcXVhbChzdGFjay5ub2RlLnJlc29sdmUoRm4uam9pbihkZWxpbWl0ZXIsIFt2YWx1ZV0pKSwgdmFsdWUpXG4gICAgICAgICksXG4gICAgICAgIHsgdmVyYm9zZTogdHJ1ZSB9XG4gICAgICApO1xuICAgIH0pLFxuICAgICdwcmUtY29uY2F0ZW5hdGVzIHN0cmluZyBsaXRlcmFscyc6IGFzeW5jVGVzdChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5zdHJpbmcoKSwgZmMuYXJyYXkobm9uRW1wdHlTdHJpbmcsIDEsIDE1KSxcbiAgICAgICAgICAoZGVsaW1pdGVyLCB2YWx1ZXMpID0+IHN0YWNrLm5vZGUucmVzb2x2ZShGbi5qb2luKGRlbGltaXRlciwgdmFsdWVzKSkgPT09IHZhbHVlcy5qb2luKGRlbGltaXRlcilcbiAgICAgICAgKSxcbiAgICAgICAgeyB2ZXJib3NlOiB0cnVlIH1cbiAgICAgICk7XG4gICAgfSksXG4gICAgJ3ByZS1jb25jYXRlbmF0ZXMgYXJvdW5kIHRva2Vucyc6IGFzeW5jVGVzdChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5zdHJpbmcoKSwgZmMuYXJyYXkobm9uRW1wdHlTdHJpbmcsIDEsIDMpLCB0b2tlbmlzaCwgZmMuYXJyYXkobm9uRW1wdHlTdHJpbmcsIDEsIDMpLFxuICAgICAgICAgIChkZWxpbWl0ZXIsIHByZWZpeCwgb2JqLCBzdWZmaXgpID0+XG4gICAgICAgICAgICBfLmlzRXF1YWwoc3RhY2subm9kZS5yZXNvbHZlKEZuLmpvaW4oZGVsaW1pdGVyLCBbLi4ucHJlZml4LCBzdHJpbmdUb2tlbihvYmopLCAuLi5zdWZmaXhdKSksXG4gICAgICAgICAgICAgICAgICAgICAgeyAnRm46OkpvaW4nOiBbZGVsaW1pdGVyLCBbcHJlZml4LmpvaW4oZGVsaW1pdGVyKSwgb2JqLCBzdWZmaXguam9pbihkZWxpbWl0ZXIpXV0gfSlcbiAgICAgICAgKSxcbiAgICAgICAgeyB2ZXJib3NlOiB0cnVlLCBzZWVkOiAxNTM5ODc0NjQ1MDA1LCBwYXRoOiBcIjA6MDowOjA6MDowOjA6MDowXCIgfVxuICAgICAgKTtcbiAgICB9KSxcbiAgICAnZmxhdHRlbnMgam9pbnMgbmVzdGVkIHVuZGVyIGpvaW5zIHdpdGggc2FtZSBkZWxpbWl0ZXInOiBhc3luY1Rlc3QoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuc3RyaW5nKCksIGZjLmFycmF5KGFueVZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICBmYy5hcnJheShhbnlWYWx1ZSwgMSwgMyksXG4gICAgICAgICAgICAgICAgICAgICAgZmMuYXJyYXkoYW55VmFsdWUpLFxuICAgICAgICAgIChkZWxpbWl0ZXIsIHByZWZpeCwgbmVzdGVkLCBzdWZmaXgpID0+XG4gICAgICAgICAgICAvLyBHb25uYSB0ZXN0XG4gICAgICAgICAgICBfLmlzRXF1YWwoc3RhY2subm9kZS5yZXNvbHZlKEZuLmpvaW4oZGVsaW1pdGVyLCBbLi4ucHJlZml4LCBGbi5qb2luKGRlbGltaXRlciwgbmVzdGVkKSwgLi4uc3VmZml4XSkpLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLm5vZGUucmVzb2x2ZShGbi5qb2luKGRlbGltaXRlciwgWy4uLnByZWZpeCwgLi4ubmVzdGVkLCAuLi5zdWZmaXhdKSkpXG4gICAgICAgICksXG4gICAgICAgIHsgdmVyYm9zZTogdHJ1ZSB9XG4gICAgICApO1xuICAgIH0pLFxuICAgICdkb2VzIG5vdCBmbGF0dGVuIGpvaW5zIG5lc3RlZCB1bmRlciBqb2lucyB3aXRoIGRpZmZlcmVudCBkZWxpbWl0ZXInOiBhc3luY1Rlc3QoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuc3RyaW5nKCksIGZjLnN0cmluZygpLFxuICAgICAgICAgIGZjLmFycmF5KGFueVZhbHVlLCAxLCAzKSxcbiAgICAgICAgICBmYy5hcnJheSh0b2tlbmlzaCwgMiwgMyksXG4gICAgICAgICAgZmMuYXJyYXkoYW55VmFsdWUsIDMpLFxuICAgICAgICAgIChkZWxpbWl0ZXIxLCBkZWxpbWl0ZXIyLCBwcmVmaXgsICBuZXN0ZWQsIHN1ZmZpeCkgPT4ge1xuICAgICAgICAgICAgZmMucHJlKGRlbGltaXRlcjEgIT09IGRlbGltaXRlcjIpO1xuICAgICAgICAgICAgY29uc3Qgam9pbiA9IEZuLmpvaW4oZGVsaW1pdGVyMSwgWy4uLnByZWZpeCwgRm4uam9pbihkZWxpbWl0ZXIyLCBzdHJpbmdMaXN0VG9rZW4obmVzdGVkKSksIC4uLnN1ZmZpeF0pO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBzdGFjay5ub2RlLnJlc29sdmUoam9pbik7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRbJ0ZuOjpKb2luJ11bMV0uZmluZCgoZTogYW55KSA9PiB0eXBlb2YgZSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdGbjo6Sm9pbicgaW4gZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgZVsnRm46OkpvaW4nXVswXSA9PT0gZGVsaW1pdGVyMikgIT0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgdmVyYm9zZTogdHJ1ZSB9XG4gICAgICApO1xuICAgIH0pLFxuICB9LFxufSk7XG5cbmZ1bmN0aW9uIHN0cmluZ0xpc3RUb2tlbihvOiBhbnkpOiBzdHJpbmdbXSB7XG4gIHJldHVybiBuZXcgVG9rZW4obykudG9MaXN0KCk7XG59XG5mdW5jdGlvbiBzdHJpbmdUb2tlbihvOiBhbnkpOiBzdHJpbmcge1xuICByZXR1cm4gbmV3IFRva2VuKG8pLnRvU3RyaW5nKCk7XG59XG4iXX0=