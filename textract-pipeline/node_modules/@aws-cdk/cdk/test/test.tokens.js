"use strict";
const lib_1 = require("../lib");
const evaluate_cfn_1 = require("./evaluate-cfn");
class Promise2 extends lib_1.Token {
    resolve() {
        return {
            Data: {
                stringProp: 'hello',
                numberProp: 1234,
            },
            Recurse: new lib_1.Token(() => 42)
        };
    }
}
class Promise1 extends lib_1.Token {
    constructor() {
        super(...arguments);
        this.p2 = [new Promise2(), new Promise2()];
    }
    resolve() {
        return this.p2;
    }
}
class BaseDataType {
    constructor(foo) {
        this.foo = foo;
    }
}
class DataType extends BaseDataType {
    constructor() {
        super(12);
        this.goo = 'hello';
    }
}
/**
 * Return various flavors of Tokens that resolve to the given value
 */
function literalTokensThatResolveTo(value) {
    return [
        new lib_1.Token(value),
        new lib_1.Token(() => value)
    ];
}
/**
 * Return various flavors of Tokens that resolve to the given value
 */
function cloudFormationTokensThatResolveTo(value) {
    return [
        new lib_1.Token(value),
        new lib_1.Token(() => value)
    ];
}
/**
 * Return Tokens in both flavors that resolve to the given string
 */
function tokensThatResolveTo(value) {
    return literalTokensThatResolveTo(value).concat(cloudFormationTokensThatResolveTo(value));
}
/**
 * Wrapper for resolve that creates an throwaway Construct to call it on
 *
 * So I don't have to change all call sites in this file.
 */
function resolve(x) {
    return new lib_1.Root().node.resolve(x);
}
module.exports = {
    'resolve a plain old object should just return the object'(test) {
        const obj = { PlainOldObject: 123, Array: [1, 2, 3] };
        test.deepEqual(resolve(obj), obj);
        test.done();
    },
    'if a value is an object with a token value, it will be evaluated'(test) {
        const obj = {
            RegularValue: 'hello',
            LazyValue: new lib_1.Token('World')
        };
        test.deepEqual(resolve(obj), {
            RegularValue: 'hello',
            LazyValue: 'World'
        });
        test.done();
    },
    'tokens are evaluated anywhere in the object tree'(test) {
        const obj = new Promise1();
        const actual = resolve({ Obj: obj });
        test.deepEqual(actual, {
            Obj: [
                {
                    Data: {
                        stringProp: "hello",
                        numberProp: 1234
                    },
                    Recurse: 42
                },
                {
                    Data: {
                        stringProp: "hello",
                        numberProp: 1234
                    },
                    Recurse: 42
                }
            ]
        });
        test.done();
    },
    'tokens are evaluated recursively'(test) {
        const obj = new Promise1();
        const actual = resolve(new lib_1.Token(() => ({ Obj: obj })));
        test.deepEqual(actual, {
            Obj: [
                {
                    Data: {
                        stringProp: "hello",
                        numberProp: 1234
                    },
                    Recurse: 42
                },
                {
                    Data: {
                        stringProp: "hello",
                        numberProp: 1234
                    },
                    Recurse: 42
                }
            ]
        });
        test.done();
    },
    'empty arrays or objects are kept'(test) {
        test.deepEqual(resolve({}), {});
        test.deepEqual(resolve([]), []);
        const obj = {
            Prop1: 1234,
            Prop2: {},
            Prop3: [],
            Prop4: 'hello',
            Prop5: {
                PropA: {},
                PropB: {
                    PropC: [undefined, undefined],
                    PropD: 'Yoohoo'
                }
            }
        };
        test.deepEqual(resolve(obj), {
            Prop1: 1234,
            Prop2: {},
            Prop3: [],
            Prop4: 'hello',
            Prop5: {
                PropA: {},
                PropB: {
                    PropC: [],
                    PropD: 'Yoohoo'
                }
            }
        });
        test.done();
    },
    'if an object has a "resolve" property that is not a function, it is not considered a token'(test) {
        test.deepEqual(resolve({ a_token: { resolve: () => 78787 } }), { a_token: 78787 });
        test.deepEqual(resolve({ not_a_token: { resolve: 12 } }), { not_a_token: { resolve: 12 } });
        test.done();
    },
    // tslint:disable-next-line:max-line-length
    'if a resolvable object inherits from a class that is also resolvable, the "constructor" function will not get in the way (uses Object.keys instead of "for in")'(test) {
        test.deepEqual(resolve({ prop: new DataType() }), { prop: { foo: 12, goo: 'hello' } });
        test.done();
    },
    'isToken(obj) can be used to determine if an object is a token'(test) {
        test.ok(lib_1.unresolved({ resolve: () => 123 }));
        test.ok(lib_1.unresolved({ a: 1, b: 2, resolve: () => 'hello' }));
        test.ok(!lib_1.unresolved({ a: 1, b: 2, resolve: 3 }));
        test.done();
    },
    'Token can be used to create tokens that contain a constant value'(test) {
        test.equal(resolve(new lib_1.Token(12)), 12);
        test.equal(resolve(new lib_1.Token('hello')), 'hello');
        test.deepEqual(resolve(new lib_1.Token(['hi', 'there'])), ['hi', 'there']);
        test.done();
    },
    'resolving leaves a Date object in working order'(test) {
        const date = new Date('2000-01-01');
        const resolved = resolve(date);
        test.equal(date.toString(), resolved.toString());
        test.done();
    },
    'tokens can be stringified and evaluated to conceptual value'(test) {
        // GIVEN
        const token = new lib_1.Token(() => 'woof woof');
        // WHEN
        const stringified = `The dog says: ${token}`;
        const resolved = resolve(stringified);
        // THEN
        test.deepEqual(evaluate_cfn_1.evaluateCFN(resolved), 'The dog says: woof woof');
        test.done();
    },
    'Tokens stringification and reversing of CloudFormation Tokens is implemented using Fn::Join'(test) {
        // GIVEN
        const token = new lib_1.Token(() => ({ woof: 'woof' }));
        // WHEN
        const stringified = `The dog says: ${token}`;
        const resolved = resolve(stringified);
        // THEN
        test.deepEqual(resolved, {
            'Fn::Join': ['', ['The dog says: ', { woof: 'woof' }]]
        });
        test.done();
    },
    'Doubly nested strings evaluate correctly in scalar context'(test) {
        // GIVEN
        const token1 = new lib_1.Token(() => "world");
        const token2 = new lib_1.Token(() => `hello ${token1}`);
        // WHEN
        const resolved1 = resolve(token2.toString());
        const resolved2 = resolve(token2);
        // THEN
        test.deepEqual(evaluate_cfn_1.evaluateCFN(resolved1), "hello world");
        test.deepEqual(evaluate_cfn_1.evaluateCFN(resolved2), "hello world");
        test.done();
    },
    'integer Tokens can be stringified and evaluate to conceptual value'(test) {
        // GIVEN
        for (const token of literalTokensThatResolveTo(1)) {
            // WHEN
            const stringified = `the number is ${token}`;
            const resolved = resolve(stringified);
            // THEN
            test.deepEqual(evaluate_cfn_1.evaluateCFN(resolved), 'the number is 1');
        }
        test.done();
    },
    'intrinsic Tokens can be stringified and evaluate to conceptual value'(test) {
        // GIVEN
        for (const bucketName of cloudFormationTokensThatResolveTo({ Ref: 'MyBucket' })) {
            // WHEN
            const resolved = resolve(`my bucket is named ${bucketName}`);
            // THEN
            const context = { MyBucket: 'TheName' };
            test.equal(evaluate_cfn_1.evaluateCFN(resolved, context), 'my bucket is named TheName');
        }
        test.done();
    },
    'tokens resolve properly in initial position'(test) {
        // GIVEN
        for (const token of tokensThatResolveTo('Hello')) {
            // WHEN
            const resolved = resolve(`${token} world`);
            // THEN
            test.equal(evaluate_cfn_1.evaluateCFN(resolved), 'Hello world');
        }
        test.done();
    },
    'side-by-side Tokens resolve correctly'(test) {
        // GIVEN
        for (const token1 of tokensThatResolveTo('Hello ')) {
            for (const token2 of tokensThatResolveTo('world')) {
                // WHEN
                const resolved = resolve(`${token1}${token2}`);
                // THEN
                test.equal(evaluate_cfn_1.evaluateCFN(resolved), 'Hello world');
            }
        }
        test.done();
    },
    'tokens can be used in hash keys but must resolve to a string'(test) {
        // GIVEN
        const token = new lib_1.Token(() => 'I am a string');
        // WHEN
        const s = {
            [token.toString()]: `boom ${token}`
        };
        // THEN
        test.deepEqual(resolve(s), { 'I am a string': 'boom I am a string' });
        test.done();
    },
    'fails if token in a hash key resolves to a non-string'(test) {
        // GIVEN
        const token = new lib_1.Token({ Ref: 'Other' });
        // WHEN
        const s = {
            [token.toString()]: `boom ${token}`
        };
        // THEN
        test.throws(() => resolve(s), 'The key "${Token[TOKEN.19]}" has been resolved to {"Ref":"Other"} but must be resolvable to a string');
        test.done();
    },
    'list encoding': {
        'can encode Token to string and resolve the encoding'(test) {
            // GIVEN
            const token = new lib_1.Token({ Ref: 'Other' });
            // WHEN
            const struct = {
                XYZ: token.toList()
            };
            // THEN
            test.deepEqual(resolve(struct), {
                XYZ: { Ref: 'Other' }
            });
            test.done();
        },
        'cannot add to encoded list'(test) {
            // GIVEN
            const token = new lib_1.Token({ Ref: 'Other' });
            // WHEN
            const encoded = token.toList();
            encoded.push('hello');
            // THEN
            test.throws(() => {
                resolve(encoded);
            }, /Cannot add elements to list token/);
            test.done();
        },
        'cannot add to strings in encoded list'(test) {
            // GIVEN
            const token = new lib_1.Token({ Ref: 'Other' });
            // WHEN
            const encoded = token.toList();
            encoded[0] += 'hello';
            // THEN
            test.throws(() => {
                resolve(encoded);
            }, /concatenate strings in/);
            test.done();
        },
        'can pass encoded lists to FnSelect'(test) {
            // GIVEN
            const encoded = new lib_1.Token({ Ref: 'Other' }).toList();
            // WHEN
            const struct = lib_1.Fn.select(1, encoded);
            // THEN
            test.deepEqual(resolve(struct), {
                'Fn::Select': [1, { Ref: 'Other' }]
            });
            test.done();
        },
        'can pass encoded lists to FnJoin'(test) {
            // GIVEN
            const encoded = new lib_1.Token({ Ref: 'Other' }).toList();
            // WHEN
            const struct = lib_1.Fn.join('/', encoded);
            // THEN
            test.deepEqual(resolve(struct), {
                'Fn::Join': ['/', { Ref: 'Other' }]
            });
            test.done();
        },
        'can pass encoded lists to FnJoin, even if join is stringified'(test) {
            // GIVEN
            const encoded = new lib_1.Token({ Ref: 'Other' }).toList();
            // WHEN
            const struct = lib_1.Fn.join('/', encoded).toString();
            // THEN
            test.deepEqual(resolve(struct), {
                'Fn::Join': ['/', { Ref: 'Other' }]
            });
            test.done();
        },
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC50b2tlbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0ZXN0LnRva2Vucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsZ0NBQXFEO0FBQ3JELGlEQUE2QztBQWdYN0MsTUFBTSxRQUFTLFNBQVEsV0FBSztJQUNuQixPQUFPO1FBQ1osT0FBTztZQUNMLElBQUksRUFBRTtnQkFDSixVQUFVLEVBQUUsT0FBTztnQkFDbkIsVUFBVSxFQUFFLElBQUk7YUFDakI7WUFDRCxPQUFPLEVBQUUsSUFBSSxXQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDO1NBQzdCLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFFRCxNQUFNLFFBQVMsU0FBUSxXQUFLO0lBQTVCOztRQUNTLE9BQUUsR0FBRyxDQUFFLElBQUksUUFBUSxFQUFFLEVBQUUsSUFBSSxRQUFRLEVBQUUsQ0FBRSxDQUFDO0lBS2pELENBQUM7SUFIUSxPQUFPO1FBQ1osT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBQ2pCLENBQUM7Q0FDRjtBQUVELE1BQU0sWUFBWTtJQUNoQixZQUFxQixHQUFXO1FBQVgsUUFBRyxHQUFILEdBQUcsQ0FBUTtJQUNoQyxDQUFDO0NBQ0Y7QUFFRCxNQUFNLFFBQVMsU0FBUSxZQUFZO0lBR2pDO1FBQ0UsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBSEwsUUFBRyxHQUFHLE9BQU8sQ0FBQztJQUlyQixDQUFDO0NBQ0Y7QUFFRDs7R0FFRztBQUNILFNBQVMsMEJBQTBCLENBQUMsS0FBVTtJQUM1QyxPQUFPO1FBQ0wsSUFBSSxXQUFLLENBQUMsS0FBSyxDQUFDO1FBQ2hCLElBQUksV0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQztLQUN2QixDQUFDO0FBQ0osQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxpQ0FBaUMsQ0FBQyxLQUFVO0lBQ25ELE9BQU87UUFDTCxJQUFJLFdBQUssQ0FBQyxLQUFLLENBQUM7UUFDaEIsSUFBSSxX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Q1IsTUFBTSxPQUFPLEdBQWEsSUFBSSxXQUFLLENBQUMsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUUvRCxPQUFPO1lBQ1AsTUFBTSxNQUFNLEdBQUcsUUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7WUFFaEQsT0FBTztZQUNQLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUM5QixVQUFVLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFDLENBQUM7YUFDbkMsQ0FBQyxDQUFDO1lBRUgsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2QsQ0FBQztLQUNGO0NBQ0YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRlc3QgfSBmcm9tICdub2RldW5pdCc7XG5pbXBvcnQgeyBGbiwgUm9vdCwgVG9rZW4sIHVucmVzb2x2ZWQgfSBmcm9tICcuLi9saWInO1xuaW1wb3J0IHsgZXZhbHVhdGVDRk4gfSBmcm9tICcuL2V2YWx1YXRlLWNmbic7XG5cbmV4cG9ydCA9IHtcbiAgJ3Jlc29sdmUgYSBwbGFpbiBvbGQgb2JqZWN0IHNob3VsZCBqdXN0IHJldHVybiB0aGUgb2JqZWN0Jyh0ZXN0OiBUZXN0KSB7XG4gICAgY29uc3Qgb2JqID0geyBQbGFpbk9sZE9iamVjdDogMTIzLCBBcnJheTogWyAxLCAyLCAzIF0gfTtcbiAgICB0ZXN0LmRlZXBFcXVhbChyZXNvbHZlKG9iaiksIG9iaik7XG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ2lmIGEgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYSB0b2tlbiB2YWx1ZSwgaXQgd2lsbCBiZSBldmFsdWF0ZWQnKHRlc3Q6IFRlc3QpIHtcbiAgICBjb25zdCBvYmogPSB7XG4gICAgICBSZWd1bGFyVmFsdWU6ICdoZWxsbycsXG4gICAgICBMYXp5VmFsdWU6IG5ldyBUb2tlbignV29ybGQnKVxuICAgIH07XG5cbiAgICB0ZXN0LmRlZXBFcXVhbChyZXNvbHZlKG9iaiksIHtcbiAgICAgIFJlZ3VsYXJWYWx1ZTogJ2hlbGxvJyxcbiAgICAgIExhenlWYWx1ZTogJ1dvcmxkJ1xuICAgIH0pO1xuXG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ3Rva2VucyBhcmUgZXZhbHVhdGVkIGFueXdoZXJlIGluIHRoZSBvYmplY3QgdHJlZScodGVzdDogVGVzdCkge1xuICAgIGNvbnN0IG9iaiA9IG5ldyBQcm9taXNlMSgpO1xuICAgIGNvbnN0IGFjdHVhbCA9IHJlc29sdmUoeyBPYmo6IG9iaiB9KTtcblxuICAgIHRlc3QuZGVlcEVxdWFsKGFjdHVhbCwge1xuICAgICAgT2JqOiBbXG4gICAgICAgIHtcbiAgICAgICAgRGF0YToge1xuICAgICAgICAgIHN0cmluZ1Byb3A6IFwiaGVsbG9cIixcbiAgICAgICAgICBudW1iZXJQcm9wOiAxMjM0XG4gICAgICAgIH0sXG4gICAgICAgIFJlY3Vyc2U6IDQyXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgRGF0YToge1xuICAgICAgICAgIHN0cmluZ1Byb3A6IFwiaGVsbG9cIixcbiAgICAgICAgICBudW1iZXJQcm9wOiAxMjM0XG4gICAgICAgIH0sXG4gICAgICAgIFJlY3Vyc2U6IDQyXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcblxuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gICd0b2tlbnMgYXJlIGV2YWx1YXRlZCByZWN1cnNpdmVseScodGVzdDogVGVzdCkge1xuICAgIGNvbnN0IG9iaiA9IG5ldyBQcm9taXNlMSgpO1xuICAgIGNvbnN0IGFjdHVhbCA9IHJlc29sdmUobmV3IFRva2VuKCgpID0+ICh7IE9iajogb2JqIH0pKSk7XG5cbiAgICB0ZXN0LmRlZXBFcXVhbChhY3R1YWwsIHtcbiAgICAgIE9iajogW1xuICAgICAgICB7XG4gICAgICAgIERhdGE6IHtcbiAgICAgICAgICBzdHJpbmdQcm9wOiBcImhlbGxvXCIsXG4gICAgICAgICAgbnVtYmVyUHJvcDogMTIzNFxuICAgICAgICB9LFxuICAgICAgICBSZWN1cnNlOiA0MlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgIERhdGE6IHtcbiAgICAgICAgICBzdHJpbmdQcm9wOiBcImhlbGxvXCIsXG4gICAgICAgICAgbnVtYmVyUHJvcDogMTIzNFxuICAgICAgICB9LFxuICAgICAgICBSZWN1cnNlOiA0MlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnZW1wdHkgYXJyYXlzIG9yIG9iamVjdHMgYXJlIGtlcHQnKHRlc3Q6IFRlc3QpIHtcbiAgICB0ZXN0LmRlZXBFcXVhbChyZXNvbHZlKHsgfSksIHsgfSk7XG4gICAgdGVzdC5kZWVwRXF1YWwocmVzb2x2ZShbIF0pLCBbIF0pO1xuXG4gICAgY29uc3Qgb2JqID0ge1xuICAgICAgUHJvcDE6IDEyMzQsXG4gICAgICBQcm9wMjogeyB9LFxuICAgICAgUHJvcDM6IFsgXSxcbiAgICAgIFByb3A0OiAnaGVsbG8nLFxuICAgICAgUHJvcDU6IHtcbiAgICAgICAgUHJvcEE6IHsgfSxcbiAgICAgICAgUHJvcEI6IHtcbiAgICAgICAgICBQcm9wQzogWyB1bmRlZmluZWQsIHVuZGVmaW5lZCBdLFxuICAgICAgICAgIFByb3BEOiAnWW9vaG9vJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRlc3QuZGVlcEVxdWFsKHJlc29sdmUob2JqKSwge1xuICAgICAgUHJvcDE6IDEyMzQsXG4gICAgICBQcm9wMjogeyB9LFxuICAgICAgUHJvcDM6IFsgXSxcbiAgICAgIFByb3A0OiAnaGVsbG8nLFxuICAgICAgUHJvcDU6IHtcbiAgICAgICAgUHJvcEE6IHsgfSxcbiAgICAgICAgUHJvcEI6IHtcbiAgICAgICAgICBQcm9wQzogWyBdLFxuICAgICAgICAgIFByb3BEOiAnWW9vaG9vJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnaWYgYW4gb2JqZWN0IGhhcyBhIFwicmVzb2x2ZVwiIHByb3BlcnR5IHRoYXQgaXMgbm90IGEgZnVuY3Rpb24sIGl0IGlzIG5vdCBjb25zaWRlcmVkIGEgdG9rZW4nKHRlc3Q6IFRlc3QpIHtcbiAgICB0ZXN0LmRlZXBFcXVhbChyZXNvbHZlKHsgYV90b2tlbjogeyByZXNvbHZlOiAoKSA9PiA3ODc4NyB9fSksIHsgYV90b2tlbjogNzg3ODcgfSk7XG4gICAgdGVzdC5kZWVwRXF1YWwocmVzb2x2ZSh7IG5vdF9hX3Rva2VuOiB7IHJlc29sdmU6IDEyIH0gfSksICAgeyBub3RfYV90b2tlbjogeyByZXNvbHZlOiAxMiB9IH0pO1xuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgJ2lmIGEgcmVzb2x2YWJsZSBvYmplY3QgaW5oZXJpdHMgZnJvbSBhIGNsYXNzIHRoYXQgaXMgYWxzbyByZXNvbHZhYmxlLCB0aGUgXCJjb25zdHJ1Y3RvclwiIGZ1bmN0aW9uIHdpbGwgbm90IGdldCBpbiB0aGUgd2F5ICh1c2VzIE9iamVjdC5rZXlzIGluc3RlYWQgb2YgXCJmb3IgaW5cIiknKHRlc3Q6IFRlc3QpIHtcbiAgICB0ZXN0LmRlZXBFcXVhbChyZXNvbHZlKHsgcHJvcDogbmV3IERhdGFUeXBlKCkgfSksIHsgcHJvcDogeyBmb286IDEyLCBnb286ICdoZWxsbycgfSB9KTtcbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnaXNUb2tlbihvYmopIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSB0b2tlbicodGVzdDogVGVzdCkge1xuICAgIHRlc3Qub2sodW5yZXNvbHZlZCh7IHJlc29sdmU6ICgpID0+IDEyMyB9KSk7XG4gICAgdGVzdC5vayh1bnJlc29sdmVkKHsgYTogMSwgYjogMiwgcmVzb2x2ZTogKCkgPT4gJ2hlbGxvJyB9KSk7XG4gICAgdGVzdC5vayghdW5yZXNvbHZlZCh7IGE6IDEsIGI6IDIsIHJlc29sdmU6IDMgfSkpO1xuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gICdUb2tlbiBjYW4gYmUgdXNlZCB0byBjcmVhdGUgdG9rZW5zIHRoYXQgY29udGFpbiBhIGNvbnN0YW50IHZhbHVlJyh0ZXN0OiBUZXN0KSB7XG4gICAgdGVzdC5lcXVhbChyZXNvbHZlKG5ldyBUb2tlbigxMikpLCAxMik7XG4gICAgdGVzdC5lcXVhbChyZXNvbHZlKG5ldyBUb2tlbignaGVsbG8nKSksICdoZWxsbycpO1xuICAgIHRlc3QuZGVlcEVxdWFsKHJlc29sdmUobmV3IFRva2VuKFsgJ2hpJywgJ3RoZXJlJyBdKSksIFsgJ2hpJywgJ3RoZXJlJyBdKTtcbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAncmVzb2x2aW5nIGxlYXZlcyBhIERhdGUgb2JqZWN0IGluIHdvcmtpbmcgb3JkZXInKHRlc3Q6IFRlc3QpIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoJzIwMDAtMDEtMDEnKTtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmUoZGF0ZSk7XG5cbiAgICB0ZXN0LmVxdWFsKGRhdGUudG9TdHJpbmcoKSwgcmVzb2x2ZWQudG9TdHJpbmcoKSk7XG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ3Rva2VucyBjYW4gYmUgc3RyaW5naWZpZWQgYW5kIGV2YWx1YXRlZCB0byBjb25jZXB0dWFsIHZhbHVlJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCB0b2tlbiA9IG5ldyBUb2tlbigoKSA9PiAnd29vZiB3b29mJyk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29uc3Qgc3RyaW5naWZpZWQgPSBgVGhlIGRvZyBzYXlzOiAke3Rva2VufWA7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlKHN0cmluZ2lmaWVkKTtcblxuICAgIC8vIFRIRU5cbiAgICB0ZXN0LmRlZXBFcXVhbChldmFsdWF0ZUNGTihyZXNvbHZlZCksICdUaGUgZG9nIHNheXM6IHdvb2Ygd29vZicpO1xuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gICdUb2tlbnMgc3RyaW5naWZpY2F0aW9uIGFuZCByZXZlcnNpbmcgb2YgQ2xvdWRGb3JtYXRpb24gVG9rZW5zIGlzIGltcGxlbWVudGVkIHVzaW5nIEZuOjpKb2luJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCB0b2tlbiA9IG5ldyBUb2tlbigoKSA9PiAoeyB3b29mOiAnd29vZicgfSkpO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IHN0cmluZ2lmaWVkID0gYFRoZSBkb2cgc2F5czogJHt0b2tlbn1gO1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZShzdHJpbmdpZmllZCk7XG5cbiAgICAvLyBUSEVOXG4gICAgdGVzdC5kZWVwRXF1YWwocmVzb2x2ZWQsIHtcbiAgICAgICdGbjo6Sm9pbic6IFsnJywgWydUaGUgZG9nIHNheXM6ICcsIHsgd29vZjogJ3dvb2YnIH1dXVxuICAgIH0pO1xuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gICdEb3VibHkgbmVzdGVkIHN0cmluZ3MgZXZhbHVhdGUgY29ycmVjdGx5IGluIHNjYWxhciBjb250ZXh0Jyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCB0b2tlbjEgPSBuZXcgVG9rZW4oKCkgPT4gXCJ3b3JsZFwiKTtcbiAgICBjb25zdCB0b2tlbjIgPSBuZXcgVG9rZW4oKCkgPT4gYGhlbGxvICR7dG9rZW4xfWApO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IHJlc29sdmVkMSA9IHJlc29sdmUodG9rZW4yLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IHJlc29sdmVkMiA9IHJlc29sdmUodG9rZW4yKTtcblxuICAgIC8vIFRIRU5cbiAgICB0ZXN0LmRlZXBFcXVhbChldmFsdWF0ZUNGTihyZXNvbHZlZDEpLCBcImhlbGxvIHdvcmxkXCIpO1xuICAgIHRlc3QuZGVlcEVxdWFsKGV2YWx1YXRlQ0ZOKHJlc29sdmVkMiksIFwiaGVsbG8gd29ybGRcIik7XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnaW50ZWdlciBUb2tlbnMgY2FuIGJlIHN0cmluZ2lmaWVkIGFuZCBldmFsdWF0ZSB0byBjb25jZXB0dWFsIHZhbHVlJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIGxpdGVyYWxUb2tlbnNUaGF0UmVzb2x2ZVRvKDEpKSB7XG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCBzdHJpbmdpZmllZCA9IGB0aGUgbnVtYmVyIGlzICR7dG9rZW59YDtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZShzdHJpbmdpZmllZCk7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIHRlc3QuZGVlcEVxdWFsKGV2YWx1YXRlQ0ZOKHJlc29sdmVkKSwgJ3RoZSBudW1iZXIgaXMgMScpO1xuICAgIH1cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnaW50cmluc2ljIFRva2VucyBjYW4gYmUgc3RyaW5naWZpZWQgYW5kIGV2YWx1YXRlIHRvIGNvbmNlcHR1YWwgdmFsdWUnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGZvciAoY29uc3QgYnVja2V0TmFtZSBvZiBjbG91ZEZvcm1hdGlvblRva2Vuc1RoYXRSZXNvbHZlVG8oeyBSZWY6ICdNeUJ1Y2tldCcgfSkpIHtcbiAgICAgIC8vIFdIRU5cbiAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZShgbXkgYnVja2V0IGlzIG5hbWVkICR7YnVja2V0TmFtZX1gKTtcblxuICAgICAgLy8gVEhFTlxuICAgICAgY29uc3QgY29udGV4dCA9IHtNeUJ1Y2tldDogJ1RoZU5hbWUnfTtcbiAgICAgIHRlc3QuZXF1YWwoZXZhbHVhdGVDRk4ocmVzb2x2ZWQsIGNvbnRleHQpLCAnbXkgYnVja2V0IGlzIG5hbWVkIFRoZU5hbWUnKTtcbiAgICB9XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAndG9rZW5zIHJlc29sdmUgcHJvcGVybHkgaW4gaW5pdGlhbCBwb3NpdGlvbicodGVzdDogVGVzdCkge1xuICAgIC8vIEdJVkVOXG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnNUaGF0UmVzb2x2ZVRvKCdIZWxsbycpKSB7XG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmUoYCR7dG9rZW59IHdvcmxkYCk7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIHRlc3QuZXF1YWwoZXZhbHVhdGVDRk4ocmVzb2x2ZWQpLCAnSGVsbG8gd29ybGQnKTtcbiAgICB9XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnc2lkZS1ieS1zaWRlIFRva2VucyByZXNvbHZlIGNvcnJlY3RseScodGVzdDogVGVzdCkge1xuICAgIC8vIEdJVkVOXG4gICAgZm9yIChjb25zdCB0b2tlbjEgb2YgdG9rZW5zVGhhdFJlc29sdmVUbygnSGVsbG8gJykpIHtcbiAgICAgIGZvciAoY29uc3QgdG9rZW4yIG9mIHRva2Vuc1RoYXRSZXNvbHZlVG8oJ3dvcmxkJykpIHtcbiAgICAgICAgLy8gV0hFTlxuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmUoYCR7dG9rZW4xfSR7dG9rZW4yfWApO1xuXG4gICAgICAgIC8vIFRIRU5cbiAgICAgICAgdGVzdC5lcXVhbChldmFsdWF0ZUNGTihyZXNvbHZlZCksICdIZWxsbyB3b3JsZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gICd0b2tlbnMgY2FuIGJlIHVzZWQgaW4gaGFzaCBrZXlzIGJ1dCBtdXN0IHJlc29sdmUgdG8gYSBzdHJpbmcnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHRva2VuID0gbmV3IFRva2VuKCgpID0+ICdJIGFtIGEgc3RyaW5nJyk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29uc3QgcyA9IHtcbiAgICAgIFt0b2tlbi50b1N0cmluZygpXTogYGJvb20gJHt0b2tlbn1gXG4gICAgfTtcblxuICAgIC8vIFRIRU5cbiAgICB0ZXN0LmRlZXBFcXVhbChyZXNvbHZlKHMpLCB7ICdJIGFtIGEgc3RyaW5nJzogJ2Jvb20gSSBhbSBhIHN0cmluZycgfSk7XG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ2ZhaWxzIGlmIHRva2VuIGluIGEgaGFzaCBrZXkgcmVzb2x2ZXMgdG8gYSBub24tc3RyaW5nJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCB0b2tlbiA9IG5ldyBUb2tlbih7IFJlZjogJ090aGVyJyB9KTtcblxuICAgIC8vIFdIRU5cbiAgICBjb25zdCBzID0ge1xuICAgICAgW3Rva2VuLnRvU3RyaW5nKCldOiBgYm9vbSAke3Rva2VufWBcbiAgICB9O1xuXG4gICAgLy8gVEhFTlxuICAgIHRlc3QudGhyb3dzKCgpID0+IHJlc29sdmUocyksICdUaGUga2V5IFwiJHtUb2tlbltUT0tFTi4xOV19XCIgaGFzIGJlZW4gcmVzb2x2ZWQgdG8ge1wiUmVmXCI6XCJPdGhlclwifSBidXQgbXVzdCBiZSByZXNvbHZhYmxlIHRvIGEgc3RyaW5nJyk7XG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ2xpc3QgZW5jb2RpbmcnOiB7XG4gICAgJ2NhbiBlbmNvZGUgVG9rZW4gdG8gc3RyaW5nIGFuZCByZXNvbHZlIHRoZSBlbmNvZGluZycodGVzdDogVGVzdCkge1xuICAgICAgLy8gR0lWRU5cbiAgICAgIGNvbnN0IHRva2VuID0gbmV3IFRva2VuKHsgUmVmOiAnT3RoZXInIH0pO1xuXG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCBzdHJ1Y3QgPSB7XG4gICAgICAgIFhZWjogdG9rZW4udG9MaXN0KClcbiAgICAgIH07XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIHRlc3QuZGVlcEVxdWFsKHJlc29sdmUoc3RydWN0KSwge1xuICAgICAgICBYWVo6IHsgUmVmOiAnT3RoZXInfVxuICAgICAgfSk7XG5cbiAgICAgIHRlc3QuZG9uZSgpO1xuICAgIH0sXG5cbiAgICAnY2Fubm90IGFkZCB0byBlbmNvZGVkIGxpc3QnKHRlc3Q6IFRlc3QpIHtcbiAgICAgIC8vIEdJVkVOXG4gICAgICBjb25zdCB0b2tlbiA9IG5ldyBUb2tlbih7IFJlZjogJ090aGVyJyB9KTtcblxuICAgICAgLy8gV0hFTlxuICAgICAgY29uc3QgZW5jb2RlZDogc3RyaW5nW10gPSB0b2tlbi50b0xpc3QoKTtcbiAgICAgIGVuY29kZWQucHVzaCgnaGVsbG8nKTtcblxuICAgICAgLy8gVEhFTlxuICAgICAgdGVzdC50aHJvd3MoKCkgPT4ge1xuICAgICAgICByZXNvbHZlKGVuY29kZWQpO1xuICAgICAgfSwgL0Nhbm5vdCBhZGQgZWxlbWVudHMgdG8gbGlzdCB0b2tlbi8pO1xuXG4gICAgICB0ZXN0LmRvbmUoKTtcbiAgICB9LFxuXG4gICAgJ2Nhbm5vdCBhZGQgdG8gc3RyaW5ncyBpbiBlbmNvZGVkIGxpc3QnKHRlc3Q6IFRlc3QpIHtcbiAgICAgIC8vIEdJVkVOXG4gICAgICBjb25zdCB0b2tlbiA9IG5ldyBUb2tlbih7IFJlZjogJ090aGVyJyB9KTtcblxuICAgICAgLy8gV0hFTlxuICAgICAgY29uc3QgZW5jb2RlZDogc3RyaW5nW10gPSB0b2tlbi50b0xpc3QoKTtcbiAgICAgIGVuY29kZWRbMF0gKz0gJ2hlbGxvJztcblxuICAgICAgLy8gVEhFTlxuICAgICAgdGVzdC50aHJvd3MoKCkgPT4ge1xuICAgICAgICByZXNvbHZlKGVuY29kZWQpO1xuICAgICAgfSwgL2NvbmNhdGVuYXRlIHN0cmluZ3MgaW4vKTtcblxuICAgICAgdGVzdC5kb25lKCk7XG4gICAgfSxcblxuICAgICdjYW4gcGFzcyBlbmNvZGVkIGxpc3RzIHRvIEZuU2VsZWN0Jyh0ZXN0OiBUZXN0KSB7XG4gICAgICAvLyBHSVZFTlxuICAgICAgY29uc3QgZW5jb2RlZDogc3RyaW5nW10gPSBuZXcgVG9rZW4oeyBSZWY6ICdPdGhlcicgfSkudG9MaXN0KCk7XG5cbiAgICAgIC8vIFdIRU5cbiAgICAgIGNvbnN0IHN0cnVjdCA9IEZuLnNlbGVjdCgxLCBlbmNvZGVkKTtcblxuICAgICAgLy8gVEhFTlxuICAgICAgdGVzdC5kZWVwRXF1YWwocmVzb2x2ZShzdHJ1Y3QpLCB7XG4gICAgICAgICdGbjo6U2VsZWN0JzogWzEsIHsgUmVmOiAnT3RoZXInfV1cbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0LmRvbmUoKTtcbiAgICB9LFxuXG4gICAgJ2NhbiBwYXNzIGVuY29kZWQgbGlzdHMgdG8gRm5Kb2luJyh0ZXN0OiBUZXN0KSB7XG4gICAgICAvLyBHSVZFTlxuICAgICAgY29uc3QgZW5jb2RlZDogc3RyaW5nW10gPSBuZXcgVG9rZW4oeyBSZWY6ICdPdGhlcicgfSkudG9MaXN0KCk7XG5cbiAgICAgIC8vIFdIRU5cbiAgICAgIGNvbnN0IHN0cnVjdCA9IEZuLmpvaW4oJy8nLCBlbmNvZGVkKTtcblxuICAgICAgLy8gVEhFTlxuICAgICAgdGVzdC5kZWVwRXF1YWwocmVzb2x2ZShzdHJ1Y3QpLCB7XG4gICAgICAgICdGbjo6Sm9pbic6IFsnLycsIHsgUmVmOiAnT3RoZXInfV1cbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0LmRvbmUoKTtcbiAgICB9LFxuXG4gICAgJ2NhbiBwYXNzIGVuY29kZWQgbGlzdHMgdG8gRm5Kb2luLCBldmVuIGlmIGpvaW4gaXMgc3RyaW5naWZpZWQnKHRlc3Q6IFRlc3QpIHtcbiAgICAgIC8vIEdJVkVOXG4gICAgICBjb25zdCBlbmNvZGVkOiBzdHJpbmdbXSA9IG5ldyBUb2tlbih7IFJlZjogJ090aGVyJyB9KS50b0xpc3QoKTtcblxuICAgICAgLy8gV0hFTlxuICAgICAgY29uc3Qgc3RydWN0ID0gRm4uam9pbignLycsIGVuY29kZWQpLnRvU3RyaW5nKCk7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIHRlc3QuZGVlcEVxdWFsKHJlc29sdmUoc3RydWN0KSwge1xuICAgICAgICAnRm46OkpvaW4nOiBbJy8nLCB7IFJlZjogJ090aGVyJ31dXG4gICAgICB9KTtcblxuICAgICAgdGVzdC5kb25lKCk7XG4gICAgfSxcbiAgfVxufTtcblxuY2xhc3MgUHJvbWlzZTIgZXh0ZW5kcyBUb2tlbiB7XG4gIHB1YmxpYyByZXNvbHZlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBEYXRhOiB7XG4gICAgICAgIHN0cmluZ1Byb3A6ICdoZWxsbycsXG4gICAgICAgIG51bWJlclByb3A6IDEyMzQsXG4gICAgICB9LFxuICAgICAgUmVjdXJzZTogbmV3IFRva2VuKCgpID0+IDQyKVxuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgUHJvbWlzZTEgZXh0ZW5kcyBUb2tlbiB7XG4gIHB1YmxpYyBwMiA9IFsgbmV3IFByb21pc2UyKCksIG5ldyBQcm9taXNlMigpIF07XG5cbiAgcHVibGljIHJlc29sdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucDI7XG4gIH1cbn1cblxuY2xhc3MgQmFzZURhdGFUeXBlIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgZm9vOiBudW1iZXIpIHtcbiAgfVxufVxuXG5jbGFzcyBEYXRhVHlwZSBleHRlbmRzIEJhc2VEYXRhVHlwZSB7XG4gIHB1YmxpYyBnb28gPSAnaGVsbG8nO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDEyKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB2YXJpb3VzIGZsYXZvcnMgb2YgVG9rZW5zIHRoYXQgcmVzb2x2ZSB0byB0aGUgZ2l2ZW4gdmFsdWVcbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbFRva2Vuc1RoYXRSZXNvbHZlVG8odmFsdWU6IGFueSk6IFRva2VuW10ge1xuICByZXR1cm4gW1xuICAgIG5ldyBUb2tlbih2YWx1ZSksXG4gICAgbmV3IFRva2VuKCgpID0+IHZhbHVlKVxuICBdO1xufVxuXG4vKipcbiAqIFJldHVybiB2YXJpb3VzIGZsYXZvcnMgb2YgVG9rZW5zIHRoYXQgcmVzb2x2ZSB0byB0aGUgZ2l2ZW4gdmFsdWVcbiAqL1xuZnVuY3Rpb24gY2xvdWRGb3JtYXRpb25Ub2tlbnNUaGF0UmVzb2x2ZVRvKHZhbHVlOiBhbnkpOiBUb2tlbltdIHtcbiAgcmV0dXJuIFtcbiAgICBuZXcgVG9rZW4odmFsdWUpLFxuICAgIG5ldyBUb2tlbigoKSA9PiB2YWx1ZSlcbiAgXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gVG9rZW5zIGluIGJvdGggZmxhdm9ycyB0aGF0IHJlc29sdmUgdG8gdGhlIGdpdmVuIHN0cmluZ1xuICovXG5mdW5jdGlvbiB0b2tlbnNUaGF0UmVzb2x2ZVRvKHZhbHVlOiBzdHJpbmcpOiBUb2tlbltdIHtcbiAgcmV0dXJuIGxpdGVyYWxUb2tlbnNUaGF0UmVzb2x2ZVRvKHZhbHVlKS5jb25jYXQoY2xvdWRGb3JtYXRpb25Ub2tlbnNUaGF0UmVzb2x2ZVRvKHZhbHVlKSk7XG59XG5cbi8qKlxuICogV3JhcHBlciBmb3IgcmVzb2x2ZSB0aGF0IGNyZWF0ZXMgYW4gdGhyb3dhd2F5IENvbnN0cnVjdCB0byBjYWxsIGl0IG9uXG4gKlxuICogU28gSSBkb24ndCBoYXZlIHRvIGNoYW5nZSBhbGwgY2FsbCBzaXRlcyBpbiB0aGlzIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUoeDogYW55KSB7XG4gIHJldHVybiBuZXcgUm9vdCgpLm5vZGUucmVzb2x2ZSh4KTtcbn1cbiJdfQ==