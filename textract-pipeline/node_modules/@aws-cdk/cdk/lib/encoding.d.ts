import { ResolveContext, Token } from "./token";
/**
 * Central place where we keep a mapping from Tokens to their String representation
 *
 * The string representation is used to embed token into strings,
 * and stored to be able to
 *
 * All instances of TokenStringMap share the same storage, so that this process
 * works even when different copies of the library are loaded.
 */
export declare class TokenMap {
    private readonly tokenMap;
    /**
     * Generate a unique string for this Token, returning a key
     *
     * Every call for the same Token will produce a new unique string, no
     * attempt is made to deduplicate. Token objects should cache the
     * value themselves, if required.
     *
     * The token can choose (part of) its own representation string with a
     * hint. This may be used to produce aesthetically pleasing and
     * recognizable token representations for humans.
     */
    registerString(token: Token, representationHint?: string): string;
    /**
     * Generate a unique string for this Token, returning a key
     */
    registerList(token: Token, representationHint?: string): string[];
    /**
     * Returns a `TokenString` for this string.
     */
    createStringTokenString(s: string): TokenString;
    /**
     * Returns a `TokenString` for this string.
     */
    createListTokenString(s: string): TokenString;
    /**
     * Replace any Token markers in this string with their resolved values
     */
    resolveStringTokens(s: string, context: ResolveContext): any;
    resolveListTokens(xs: string[], context: ResolveContext): any;
    /**
     * Find a Token by key
     */
    lookupToken(key: string): Token;
    private register;
}
/**
 * Interface that Token joiners implement
 */
export interface ITokenJoiner {
    /**
     * The name of the joiner.
     *
     * Must be unique per joiner: this value will be used to assert that there
     * is exactly only type of joiner in a join operation.
     */
    id: string;
    /**
     * Return the language intrinsic that will combine the strings in the given engine
     */
    join(fragments: any[]): any;
}
/**
 * A string with markers in it that can be resolved to external values
 */
declare class TokenString {
    private readonly str;
    private pattern;
    constructor(str: string, quotedBeginMarker: string, idPattern: string, quotedEndMarker: string);
    /**
     * Split string on markers, substituting markers with Tokens
     */
    split(lookup: (id: string) => Token): TokenizedStringFragments;
    /**
     * Indicates if this string includes tokens.
     */
    test(): boolean;
}
/**
 * Fragments of a string with markers
 */
declare class TokenizedStringFragments {
    private readonly fragments;
    readonly length: number;
    readonly values: any[];
    addLiteral(lit: any): void;
    addUnresolved(token: Token): void;
    mapUnresolved(fn: (t: any) => any): TokenizedStringFragments;
    /**
     * Combine the resolved string fragments using the Tokens to join.
     *
     * Resolves the result.
     */
    join(concat: ConcatFunc): any;
}
/**
 * Function used to concatenate symbols in the target document language
 */
export declare type ConcatFunc = (left: any | undefined, right: any | undefined) => any;
/**
 * Singleton instance of the token string map
 */
export declare const TOKEN_MAP: TokenMap;
export declare function isListToken(x: any): boolean;
export declare function containsListToken(xs: any[]): boolean;
export {};
