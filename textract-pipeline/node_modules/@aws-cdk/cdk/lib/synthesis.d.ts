import cxapi = require('@aws-cdk/cx-api');
import { IConstruct } from './construct';
export interface ISynthesizable {
    synthesize(session: ISynthesisSession): void;
}
export interface ISynthesisSession {
    readonly store: ISessionStore;
    readonly manifest: cxapi.AssemblyManifest;
    addArtifact(id: string, droplet: cxapi.Artifact): void;
    addBuildStep(id: string, step: cxapi.BuildStep): void;
    tryGetArtifact(id: string): cxapi.Artifact | undefined;
    getArtifact(id: string): cxapi.Artifact;
}
export interface SynthesisOptions extends ManifestOptions {
    /**
     * The file store used for this session.
     * @default InMemoryStore
     */
    readonly store?: ISessionStore;
    /**
     * Whether synthesis should skip the validation phase.
     * @default false
     */
    readonly skipValidation?: boolean;
}
export declare class Synthesizer {
    synthesize(root: IConstruct, options?: SynthesisOptions): ISynthesisSession;
}
export declare class SynthesisSession implements ISynthesisSession {
    /**
     * @returns true if `obj` implements `ISynthesizable`.
     */
    static isSynthesizable(obj: any): obj is ISynthesizable;
    readonly store: ISessionStore;
    private readonly artifacts;
    private readonly buildSteps;
    private _manifest?;
    constructor(options: SynthesisOptions);
    readonly manifest: cxapi.AssemblyManifest;
    addArtifact(id: string, artifact: cxapi.Artifact): void;
    tryGetArtifact(id: string): cxapi.Artifact | undefined;
    getArtifact(id: string): cxapi.Artifact;
    addBuildStep(id: string, step: cxapi.BuildStep): void;
    close(options?: ManifestOptions): cxapi.AssemblyManifest;
}
export interface ManifestOptions {
    /**
     * Emit the legacy manifest (`cdk.out`) when the session is closed (alongside `manifest.json`).
     * @default false
     */
    readonly legacyManifest?: boolean;
    /**
     * Include runtime information (module versions) in manifest.
     * @default true
     */
    readonly runtimeInformation?: boolean;
}
export interface ISessionStore {
    /**
     * Creates a directory and returns it's full path.
     * @param directoryName The name of the directory to create.
     * @throws if a directory by that name already exists in the session or if the session has already been finalized.
     */
    mkdir(directoryName: string): string;
    /**
     * Returns the list of files in a directory.
     * @param directoryName The name of the artifact
     * @throws if there is no directory artifact under this name
     */
    readdir(directoryName: string): string[];
    /**
     * Writes a file into the store.
     * @param artifactName The name of the file.
     * @param data The contents of the file.
     */
    writeFile(artifactName: string, data: any): void;
    /**
     * Writes a formatted JSON output file to the store
     * @param artifactName the name of the artifact
     * @param json the JSON object
     */
    writeJson(artifactName: string, json: any): void;
    /**
     * Reads a file from the store.
     * @param fileName The name of the file.
     * @throws if the file is not found
     */
    readFile(fileName: string): any;
    /**
     * Reads a JSON object from the store.
     */
    readJson(fileName: string): any;
    /**
     * @returns true if the file `fileName` exists in the store.
     * @param name The name of the file or directory to look up.
     */
    exists(name: string): boolean;
    /**
     * List all top-level files that were emitted to the store.
     */
    list(): string[];
    /**
     * Do not allow further writes into the store.
     */
    lock(): void;
}
export interface FileSystemStoreOptions {
    /**
     * The output directory for synthesis artifacts
     */
    readonly outdir: string;
}
/**
 * Can be used to prepare and emit synthesis artifacts into an output directory.
 */
export declare class FileSystemStore implements ISessionStore {
    private readonly outdir;
    private locked;
    constructor(options: FileSystemStoreOptions);
    writeFile(fileName: string, data: any): void;
    writeJson(fileName: string, json: any): void;
    readFile(fileName: string): any;
    readJson(fileName: string): any;
    exists(name: string): boolean;
    mkdir(directoryName: string): string;
    readdir(directoryName: string): string[];
    list(): string[];
    lock(): void;
    private pathForArtifact;
    private canWrite;
}
export declare class InMemoryStore implements ISessionStore {
    private files;
    private dirs;
    private locked;
    writeFile(fileName: string, data: any): void;
    writeJson(fileName: string, json: any): void;
    readFile(fileName: string): any;
    readJson(fileName: string): any;
    exists(name: string): boolean;
    mkdir(directoryName: string): string;
    readdir(directoryName: string): string[];
    list(): string[];
    lock(): void;
    private canWrite;
}
export declare function renderLegacyStacks(manifest: cxapi.AssemblyManifest, store: ISessionStore): cxapi.SynthesizedStack[];
