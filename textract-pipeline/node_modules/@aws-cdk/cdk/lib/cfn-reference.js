"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const reference_1 = require("./reference");
const CFN_REFERENCE_SYMBOL = Symbol('@aws-cdk/cdk.CfnReference');
/**
 * A Token that represents a CloudFormation reference to another resource
 *
 * If these references are used in a different stack from where they are
 * defined, appropriate CloudFormation `Export`s and `Fn::ImportValue`s will be
 * synthesized automatically instead of the regular CloudFormation references.
 *
 * Additionally, the dependency between the stacks will be recorded, and the toolkit
 * will make sure to deploy producing stack before the consuming stack.
 *
 * This magic happens in the prepare() phase, where consuming stacks will call
 * `consumeFromStack` on these Tokens and if they happen to be exported by a different
 * Stack, we'll register the dependency.
 */
class CfnReference extends reference_1.Reference {
    /**
     * Check whether this is actually a Reference
     */
    static isCfnReference(x) {
        return x[CFN_REFERENCE_SYMBOL] === true;
    }
    constructor(value, displayName, target) {
        if (typeof (value) === 'function') {
            throw new Error('Reference can only hold CloudFormation intrinsics (not a function)');
        }
        // prepend scope path to display name
        super(value, `${target.node.id}.${displayName}`, target);
        this.originalDisplayName = displayName;
        this.replacementTokens = new Map();
        this.producingStack = target.node.stack;
        Object.defineProperty(this, CFN_REFERENCE_SYMBOL, { value: true });
    }
    resolve(context) {
        // If we have a special token for this consuming stack, resolve that. Otherwise resolve as if
        // we are in the same stack.
        const token = this.replacementTokens.get(context.scope.node.stack);
        if (token) {
            return token.resolve(context);
        }
        else {
            return super.resolve(context);
        }
    }
    /**
     * Register a stack this references is being consumed from.
     */
    consumeFromStack(consumingStack, consumingConstruct) {
        if (this.producingStack && this.producingStack !== consumingStack && !this.replacementTokens.has(consumingStack)) {
            // We're trying to resolve a cross-stack reference
            consumingStack.addDependency(this.producingStack, `${consumingConstruct.node.path} -> ${this.target.node.path}.${this.originalDisplayName}`);
            this.replacementTokens.set(consumingStack, this.exportValue(this, consumingStack));
        }
    }
    /**
     * Export a Token value for use in another stack
     *
     * Works by mutating the producing stack in-place.
     */
    exportValue(tokenValue, consumingStack) {
        const producingStack = this.producingStack;
        if (producingStack.env.account !== consumingStack.env.account || producingStack.env.region !== consumingStack.env.region) {
            throw new Error('Can only reference cross stacks in the same region and account.');
        }
        // Ensure a singleton "Exports" scoping Construct
        // This mostly exists to trigger LogicalID munging, which would be
        // disabled if we parented constructs directly under Stack.
        // Also it nicely prevents likely construct name clashes
        const exportsName = 'Exports';
        let stackExports = producingStack.node.tryFindChild(exportsName);
        if (stackExports === undefined) {
            stackExports = new construct_1.Construct(producingStack, exportsName);
        }
        // Ensure a singleton CfnOutput for this value
        const resolved = producingStack.node.resolve(tokenValue);
        const id = 'Output' + JSON.stringify(resolved);
        let output = stackExports.node.tryFindChild(id);
        if (!output) {
            output = new cfn_output_1.CfnOutput(stackExports, id, { value: tokenValue });
        }
        // We want to return an actual FnImportValue Token here, but Fn.importValue() returns a 'string',
        // so construct one in-place.
        return new token_1.Token({ 'Fn::ImportValue': output.obtainExportName() });
    }
}
exports.CfnReference = CfnReference;
const cfn_output_1 = require("./cfn-output");
const construct_1 = require("./construct");
const token_1 = require("./token");
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2ZuLXJlZmVyZW5jZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNmbi1yZWZlcmVuY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyQ0FBd0M7QUFFeEMsTUFBTSxvQkFBb0IsR0FBRyxNQUFNLENBQUMsMkJBQTJCLENBQUMsQ0FBQztBQUVqRTs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0gsTUFBYSxZQUFhLFNBQVEscUJBQVM7SUFDekM7O09BRUc7SUFDSSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQVE7UUFDbkMsT0FBUSxDQUFTLENBQUMsb0JBQW9CLENBQUMsS0FBSyxJQUFJLENBQUM7SUFDbkQsQ0FBQztJQWNELFlBQVksS0FBVSxFQUFFLFdBQW1CLEVBQUUsTUFBaUI7UUFDNUQsSUFBSSxPQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssVUFBVSxFQUFFO1lBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0VBQW9FLENBQUMsQ0FBQztTQUN6RjtRQUNELHFDQUFxQztRQUNyQyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksV0FBVyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDekQsSUFBSSxDQUFDLG1CQUFtQixHQUFHLFdBQVcsQ0FBQztRQUN2QyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxHQUFHLEVBQWdCLENBQUM7UUFFakQsSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUN4QyxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxvQkFBb0IsRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFFTSxPQUFPLENBQUMsT0FBdUI7UUFDcEMsNkZBQTZGO1FBQzdGLDRCQUE0QjtRQUM1QixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ25FLElBQUksS0FBSyxFQUFFO1lBQ1QsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQy9CO2FBQU07WUFDTCxPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDL0I7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxnQkFBZ0IsQ0FBQyxjQUFxQixFQUFFLGtCQUE4QjtRQUMzRSxJQUFJLElBQUksQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxjQUFjLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFO1lBQ2hILGtEQUFrRDtZQUNsRCxjQUFjLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxDQUFDO1lBQzdJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7U0FDcEY7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLFdBQVcsQ0FBQyxVQUFpQixFQUFFLGNBQXFCO1FBQzFELE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxjQUFlLENBQUM7UUFFNUMsSUFBSSxjQUFjLENBQUMsR0FBRyxDQUFDLE9BQU8sS0FBSyxjQUFjLENBQUMsR0FBRyxDQUFDLE9BQU8sSUFBSSxjQUFjLENBQUMsR0FBRyxDQUFDLE1BQU0sS0FBSyxjQUFjLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRTtZQUN4SCxNQUFNLElBQUksS0FBSyxDQUFDLGlFQUFpRSxDQUFDLENBQUM7U0FDcEY7UUFFRCxpREFBaUQ7UUFDakQsa0VBQWtFO1FBQ2xFLDJEQUEyRDtRQUMzRCx3REFBd0Q7UUFFeEQsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDO1FBQzlCLElBQUksWUFBWSxHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBYyxDQUFDO1FBQzlFLElBQUksWUFBWSxLQUFLLFNBQVMsRUFBRTtZQUM5QixZQUFZLEdBQUcsSUFBSSxxQkFBUyxDQUFDLGNBQWMsRUFBRSxXQUFXLENBQUMsQ0FBQztTQUMzRDtRQUVELDhDQUE4QztRQUM5QyxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN6RCxNQUFNLEVBQUUsR0FBRyxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMvQyxJQUFJLE1BQU0sR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQWMsQ0FBQztRQUM3RCxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1gsTUFBTSxHQUFHLElBQUksc0JBQVMsQ0FBQyxZQUFZLEVBQUUsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUM7U0FDakU7UUFFRCxpR0FBaUc7UUFDakcsNkJBQTZCO1FBQzdCLE9BQU8sSUFBSSxhQUFLLENBQUMsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDckUsQ0FBQztDQUVGO0FBM0ZELG9DQTJGQztBQUVELDZDQUF5QztBQUN6QywyQ0FBb0Q7QUFFcEQsbUNBQWdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVmZXJlbmNlIH0gZnJvbSBcIi4vcmVmZXJlbmNlXCI7XG5cbmNvbnN0IENGTl9SRUZFUkVOQ0VfU1lNQk9MID0gU3ltYm9sKCdAYXdzLWNkay9jZGsuQ2ZuUmVmZXJlbmNlJyk7XG5cbi8qKlxuICogQSBUb2tlbiB0aGF0IHJlcHJlc2VudHMgYSBDbG91ZEZvcm1hdGlvbiByZWZlcmVuY2UgdG8gYW5vdGhlciByZXNvdXJjZVxuICpcbiAqIElmIHRoZXNlIHJlZmVyZW5jZXMgYXJlIHVzZWQgaW4gYSBkaWZmZXJlbnQgc3RhY2sgZnJvbSB3aGVyZSB0aGV5IGFyZVxuICogZGVmaW5lZCwgYXBwcm9wcmlhdGUgQ2xvdWRGb3JtYXRpb24gYEV4cG9ydGBzIGFuZCBgRm46OkltcG9ydFZhbHVlYHMgd2lsbCBiZVxuICogc3ludGhlc2l6ZWQgYXV0b21hdGljYWxseSBpbnN0ZWFkIG9mIHRoZSByZWd1bGFyIENsb3VkRm9ybWF0aW9uIHJlZmVyZW5jZXMuXG4gKlxuICogQWRkaXRpb25hbGx5LCB0aGUgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSBzdGFja3Mgd2lsbCBiZSByZWNvcmRlZCwgYW5kIHRoZSB0b29sa2l0XG4gKiB3aWxsIG1ha2Ugc3VyZSB0byBkZXBsb3kgcHJvZHVjaW5nIHN0YWNrIGJlZm9yZSB0aGUgY29uc3VtaW5nIHN0YWNrLlxuICpcbiAqIFRoaXMgbWFnaWMgaGFwcGVucyBpbiB0aGUgcHJlcGFyZSgpIHBoYXNlLCB3aGVyZSBjb25zdW1pbmcgc3RhY2tzIHdpbGwgY2FsbFxuICogYGNvbnN1bWVGcm9tU3RhY2tgIG9uIHRoZXNlIFRva2VucyBhbmQgaWYgdGhleSBoYXBwZW4gdG8gYmUgZXhwb3J0ZWQgYnkgYSBkaWZmZXJlbnRcbiAqIFN0YWNrLCB3ZSdsbCByZWdpc3RlciB0aGUgZGVwZW5kZW5jeS5cbiAqL1xuZXhwb3J0IGNsYXNzIENmblJlZmVyZW5jZSBleHRlbmRzIFJlZmVyZW5jZSB7XG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoaXMgaXMgYWN0dWFsbHkgYSBSZWZlcmVuY2VcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaXNDZm5SZWZlcmVuY2UoeDogVG9rZW4pOiB4IGlzIENmblJlZmVyZW5jZSB7XG4gICAgcmV0dXJuICh4IGFzIGFueSlbQ0ZOX1JFRkVSRU5DRV9TWU1CT0xdID09PSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoYXQgc3RhY2sgdGhpcyBUb2tlbiBpcyBwb2ludGluZyB0b1xuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBwcm9kdWNpbmdTdGFjaz86IFN0YWNrO1xuXG4gIC8qKlxuICAgKiBUaGUgVG9rZW5zIHRoYXQgc2hvdWxkIGJlIHJldHVybmVkIGZvciBlYWNoIGNvbnN1bWluZyBzdGFjayAoYXMgZGVjaWRlZCBieSB0aGUgcHJvZHVjaW5nIFN0YWNrKVxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSByZXBsYWNlbWVudFRva2VuczogTWFwPFN0YWNrLCBUb2tlbj47XG5cbiAgcHJpdmF0ZSByZWFkb25seSBvcmlnaW5hbERpc3BsYXlOYW1lOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IodmFsdWU6IGFueSwgZGlzcGxheU5hbWU6IHN0cmluZywgdGFyZ2V0OiBDb25zdHJ1Y3QpIHtcbiAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZSBjYW4gb25seSBob2xkIENsb3VkRm9ybWF0aW9uIGludHJpbnNpY3MgKG5vdCBhIGZ1bmN0aW9uKScpO1xuICAgIH1cbiAgICAvLyBwcmVwZW5kIHNjb3BlIHBhdGggdG8gZGlzcGxheSBuYW1lXG4gICAgc3VwZXIodmFsdWUsIGAke3RhcmdldC5ub2RlLmlkfS4ke2Rpc3BsYXlOYW1lfWAsIHRhcmdldCk7XG4gICAgdGhpcy5vcmlnaW5hbERpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgdGhpcy5yZXBsYWNlbWVudFRva2VucyA9IG5ldyBNYXA8U3RhY2ssIFRva2VuPigpO1xuXG4gICAgdGhpcy5wcm9kdWNpbmdTdGFjayA9IHRhcmdldC5ub2RlLnN0YWNrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBDRk5fUkVGRVJFTkNFX1NZTUJPTCwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlKGNvbnRleHQ6IFJlc29sdmVDb250ZXh0KTogYW55IHtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgc3BlY2lhbCB0b2tlbiBmb3IgdGhpcyBjb25zdW1pbmcgc3RhY2ssIHJlc29sdmUgdGhhdC4gT3RoZXJ3aXNlIHJlc29sdmUgYXMgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGhlIHNhbWUgc3RhY2suXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLnJlcGxhY2VtZW50VG9rZW5zLmdldChjb250ZXh0LnNjb3BlLm5vZGUuc3RhY2spO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgcmV0dXJuIHRva2VuLnJlc29sdmUoY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5yZXNvbHZlKGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHN0YWNrIHRoaXMgcmVmZXJlbmNlcyBpcyBiZWluZyBjb25zdW1lZCBmcm9tLlxuICAgKi9cbiAgcHVibGljIGNvbnN1bWVGcm9tU3RhY2soY29uc3VtaW5nU3RhY2s6IFN0YWNrLCBjb25zdW1pbmdDb25zdHJ1Y3Q6IElDb25zdHJ1Y3QpIHtcbiAgICBpZiAodGhpcy5wcm9kdWNpbmdTdGFjayAmJiB0aGlzLnByb2R1Y2luZ1N0YWNrICE9PSBjb25zdW1pbmdTdGFjayAmJiAhdGhpcy5yZXBsYWNlbWVudFRva2Vucy5oYXMoY29uc3VtaW5nU3RhY2spKSB7XG4gICAgICAvLyBXZSdyZSB0cnlpbmcgdG8gcmVzb2x2ZSBhIGNyb3NzLXN0YWNrIHJlZmVyZW5jZVxuICAgICAgY29uc3VtaW5nU3RhY2suYWRkRGVwZW5kZW5jeSh0aGlzLnByb2R1Y2luZ1N0YWNrLCBgJHtjb25zdW1pbmdDb25zdHJ1Y3Qubm9kZS5wYXRofSAtPiAke3RoaXMudGFyZ2V0Lm5vZGUucGF0aH0uJHt0aGlzLm9yaWdpbmFsRGlzcGxheU5hbWV9YCk7XG4gICAgICB0aGlzLnJlcGxhY2VtZW50VG9rZW5zLnNldChjb25zdW1pbmdTdGFjaywgdGhpcy5leHBvcnRWYWx1ZSh0aGlzLCBjb25zdW1pbmdTdGFjaykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnQgYSBUb2tlbiB2YWx1ZSBmb3IgdXNlIGluIGFub3RoZXIgc3RhY2tcbiAgICpcbiAgICogV29ya3MgYnkgbXV0YXRpbmcgdGhlIHByb2R1Y2luZyBzdGFjayBpbi1wbGFjZS5cbiAgICovXG4gIHByaXZhdGUgZXhwb3J0VmFsdWUodG9rZW5WYWx1ZTogVG9rZW4sIGNvbnN1bWluZ1N0YWNrOiBTdGFjayk6IFRva2VuIHtcbiAgICBjb25zdCBwcm9kdWNpbmdTdGFjayA9IHRoaXMucHJvZHVjaW5nU3RhY2shO1xuXG4gICAgaWYgKHByb2R1Y2luZ1N0YWNrLmVudi5hY2NvdW50ICE9PSBjb25zdW1pbmdTdGFjay5lbnYuYWNjb3VudCB8fCBwcm9kdWNpbmdTdGFjay5lbnYucmVnaW9uICE9PSBjb25zdW1pbmdTdGFjay5lbnYucmVnaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHJlZmVyZW5jZSBjcm9zcyBzdGFja3MgaW4gdGhlIHNhbWUgcmVnaW9uIGFuZCBhY2NvdW50LicpO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBhIHNpbmdsZXRvbiBcIkV4cG9ydHNcIiBzY29waW5nIENvbnN0cnVjdFxuICAgIC8vIFRoaXMgbW9zdGx5IGV4aXN0cyB0byB0cmlnZ2VyIExvZ2ljYWxJRCBtdW5naW5nLCB3aGljaCB3b3VsZCBiZVxuICAgIC8vIGRpc2FibGVkIGlmIHdlIHBhcmVudGVkIGNvbnN0cnVjdHMgZGlyZWN0bHkgdW5kZXIgU3RhY2suXG4gICAgLy8gQWxzbyBpdCBuaWNlbHkgcHJldmVudHMgbGlrZWx5IGNvbnN0cnVjdCBuYW1lIGNsYXNoZXNcblxuICAgIGNvbnN0IGV4cG9ydHNOYW1lID0gJ0V4cG9ydHMnO1xuICAgIGxldCBzdGFja0V4cG9ydHMgPSBwcm9kdWNpbmdTdGFjay5ub2RlLnRyeUZpbmRDaGlsZChleHBvcnRzTmFtZSkgYXMgQ29uc3RydWN0O1xuICAgIGlmIChzdGFja0V4cG9ydHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhY2tFeHBvcnRzID0gbmV3IENvbnN0cnVjdChwcm9kdWNpbmdTdGFjaywgZXhwb3J0c05hbWUpO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBhIHNpbmdsZXRvbiBDZm5PdXRwdXQgZm9yIHRoaXMgdmFsdWVcbiAgICBjb25zdCByZXNvbHZlZCA9IHByb2R1Y2luZ1N0YWNrLm5vZGUucmVzb2x2ZSh0b2tlblZhbHVlKTtcbiAgICBjb25zdCBpZCA9ICdPdXRwdXQnICsgSlNPTi5zdHJpbmdpZnkocmVzb2x2ZWQpO1xuICAgIGxldCBvdXRwdXQgPSBzdGFja0V4cG9ydHMubm9kZS50cnlGaW5kQ2hpbGQoaWQpIGFzIENmbk91dHB1dDtcbiAgICBpZiAoIW91dHB1dCkge1xuICAgICAgb3V0cHV0ID0gbmV3IENmbk91dHB1dChzdGFja0V4cG9ydHMsIGlkLCB7IHZhbHVlOiB0b2tlblZhbHVlIH0pO1xuICAgIH1cblxuICAgIC8vIFdlIHdhbnQgdG8gcmV0dXJuIGFuIGFjdHVhbCBGbkltcG9ydFZhbHVlIFRva2VuIGhlcmUsIGJ1dCBGbi5pbXBvcnRWYWx1ZSgpIHJldHVybnMgYSAnc3RyaW5nJyxcbiAgICAvLyBzbyBjb25zdHJ1Y3Qgb25lIGluLXBsYWNlLlxuICAgIHJldHVybiBuZXcgVG9rZW4oeyAnRm46OkltcG9ydFZhbHVlJzogb3V0cHV0Lm9idGFpbkV4cG9ydE5hbWUoKSB9KTtcbiAgfVxuXG59XG5cbmltcG9ydCB7IENmbk91dHB1dCB9IGZyb20gXCIuL2Nmbi1vdXRwdXRcIjtcbmltcG9ydCB7IENvbnN0cnVjdCwgSUNvbnN0cnVjdCB9IGZyb20gXCIuL2NvbnN0cnVjdFwiO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tIFwiLi9zdGFja1wiO1xuaW1wb3J0IHsgUmVzb2x2ZUNvbnRleHQsIFRva2VuIH0gZnJvbSBcIi4vdG9rZW5cIjsiXX0=