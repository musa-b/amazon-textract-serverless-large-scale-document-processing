"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const encoding_1 = require("./encoding");
const unresolved_1 = require("./unresolved");
/**
 * If objects has a function property by this name, they will be considered tokens, and this
 * function will be called to resolve the value for this object.
 */
exports.RESOLVE_METHOD = 'resolve';
/**
 * Represents a special or lazily-evaluated value.
 *
 * Can be used to delay evaluation of a certain value in case, for example,
 * that it requires some context or late-bound data. Can also be used to
 * mark values that need special processing at document rendering time.
 *
 * Tokens can be embedded into strings while retaining their original
 * semantics.
 */
class Token {
    /**
     * Creates a token that resolves to `value`.
     *
     * If value is a function, the function is evaluated upon resolution and
     * the value it returns will be used as the token's value.
     *
     * displayName is used to represent the Token when it's embedded into a string; it
     * will look something like this:
     *
     *    "embedded in a larger string is ${Token[DISPLAY_NAME.123]}"
     *
     * This value is used as a hint to humans what the meaning of the Token is,
     * and does not have any effect on the evaluation.
     *
     * Must contain only alphanumeric and simple separator characters (_.:-).
     *
     * @param valueOrFunction What this token will evaluate to, literal or function.
     * @param displayName A human-readable display hint for this Token
     */
    constructor(valueOrFunction, displayName) {
        this.valueOrFunction = valueOrFunction;
        this.displayName = displayName;
    }
    /**
     * Returns true if obj is a token (i.e. has the resolve() method or is a string
     * that includes token markers), or it's a listifictaion of a Token string.
     *
     * @param obj The object to test.
     */
    static unresolved(obj) {
        return unresolved_1.unresolved(obj);
    }
    /**
     * @returns The resolved value for this token.
     */
    resolve(_context) {
        let value = this.valueOrFunction;
        if (typeof (value) === 'function') {
            value = value();
        }
        return value;
    }
    /**
     * Return a reversible string representation of this token
     *
     * If the Token is initialized with a literal, the stringified value of the
     * literal is returned. Otherwise, a special quoted string representation
     * of the Token is returned that can be embedded into other strings.
     *
     * Strings with quoted Tokens in them can be restored back into
     * complex values with the Tokens restored by calling `resolve()`
     * on the string.
     */
    toString() {
        const valueType = typeof this.valueOrFunction;
        // Optimization: if we can immediately resolve this, don't bother
        // registering a Token.
        if (valueType === 'string' || valueType === 'number' || valueType === 'boolean') {
            return this.valueOrFunction.toString();
        }
        if (this.tokenStringification === undefined) {
            this.tokenStringification = encoding_1.TOKEN_MAP.registerString(this, this.displayName);
        }
        return this.tokenStringification;
    }
    /**
     * Turn this Token into JSON
     *
     * This gets called by JSON.stringify(). We want to prohibit this, because
     * it's not possible to do this properly, so we just throw an error here.
     */
    toJSON() {
        // tslint:disable-next-line:max-line-length
        throw new Error('JSON.stringify() cannot be applied to structure with a Token in it. Use this.node.stringifyJson() instead.');
    }
    /**
     * Return a string list representation of this token
     *
     * Call this if the Token intrinsically evaluates to a list of strings.
     * If so, you can represent the Token in a similar way in the type
     * system.
     *
     * Note that even though the Token is represented as a list of strings, you
     * still cannot do any operations on it such as concatenation, indexing,
     * or taking its length. The only useful operations you can do to these lists
     * is constructing a `FnJoin` or a `FnSelect` on it.
     */
    toList() {
        const valueType = typeof this.valueOrFunction;
        if (valueType === 'string' || valueType === 'number' || valueType === 'boolean') {
            throw new Error('Got a literal Token value; only intrinsics can ever evaluate to lists.');
        }
        if (this.tokenListification === undefined) {
            this.tokenListification = encoding_1.TOKEN_MAP.registerList(this, this.displayName);
        }
        return this.tokenListification;
    }
}
exports.Token = Token;
/**
 * Whether the given object is an `IResolvedValuePostProcessor`
 */
function isResolvedValuePostProcessor(x) {
    return x.postProcess !== undefined;
}
exports.isResolvedValuePostProcessor = isResolvedValuePostProcessor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0b2tlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLHlDQUF1QztBQUN2Qyw2Q0FBMEM7QUFFMUM7OztHQUdHO0FBQ1UsUUFBQSxjQUFjLEdBQUcsU0FBUyxDQUFDO0FBRXhDOzs7Ozs7Ozs7R0FTRztBQUNILE1BQWEsS0FBSztJQWNoQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0JHO0lBQ0gsWUFBNkIsZUFBcUIsRUFBbUIsV0FBb0I7UUFBNUQsb0JBQWUsR0FBZixlQUFlLENBQU07UUFBbUIsZ0JBQVcsR0FBWCxXQUFXLENBQVM7SUFDekYsQ0FBQztJQWpDRDs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBUTtRQUMvQixPQUFPLHVCQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQTJCRDs7T0FFRztJQUNJLE9BQU8sQ0FBQyxRQUF3QjtRQUNyQyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO1FBQ2pDLElBQUksT0FBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLFVBQVUsRUFBRTtZQUNoQyxLQUFLLEdBQUcsS0FBSyxFQUFFLENBQUM7U0FDakI7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0ksUUFBUTtRQUNiLE1BQU0sU0FBUyxHQUFHLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUM5QyxpRUFBaUU7UUFDakUsdUJBQXVCO1FBQ3ZCLElBQUksU0FBUyxLQUFLLFFBQVEsSUFBSSxTQUFTLEtBQUssUUFBUSxJQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUU7WUFDL0UsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ3hDO1FBRUQsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEtBQUssU0FBUyxFQUFFO1lBQzNDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxvQkFBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQzlFO1FBQ0QsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUM7SUFDbkMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTTtRQUNYLDJDQUEyQztRQUMzQyxNQUFNLElBQUksS0FBSyxDQUFDLDRHQUE0RyxDQUFDLENBQUM7SUFDaEksQ0FBQztJQUVEOzs7Ozs7Ozs7OztPQVdHO0lBQ0ksTUFBTTtRQUNYLE1BQU0sU0FBUyxHQUFHLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUM5QyxJQUFJLFNBQVMsS0FBSyxRQUFRLElBQUksU0FBUyxLQUFLLFFBQVEsSUFBSSxTQUFTLEtBQUssU0FBUyxFQUFFO1lBQy9FLE1BQU0sSUFBSSxLQUFLLENBQUMsd0VBQXdFLENBQUMsQ0FBQztTQUMzRjtRQUVELElBQUksSUFBSSxDQUFDLGtCQUFrQixLQUFLLFNBQVMsRUFBRTtZQUN6QyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsb0JBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUMxRTtRQUNELE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDO0lBQ2pDLENBQUM7Q0FDRjtBQTNHRCxzQkEyR0M7QUFvQkQ7O0dBRUc7QUFDSCxTQUFnQiw0QkFBNEIsQ0FBQyxDQUFNO0lBQ2pELE9BQU8sQ0FBQyxDQUFDLFdBQVcsS0FBSyxTQUFTLENBQUM7QUFDckMsQ0FBQztBQUZELG9FQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUNvbnN0cnVjdCB9IGZyb20gXCIuL2NvbnN0cnVjdFwiO1xuaW1wb3J0IHsgVE9LRU5fTUFQIH0gZnJvbSBcIi4vZW5jb2RpbmdcIjtcbmltcG9ydCB7IHVucmVzb2x2ZWQgfSBmcm9tICcuL3VucmVzb2x2ZWQnO1xuXG4vKipcbiAqIElmIG9iamVjdHMgaGFzIGEgZnVuY3Rpb24gcHJvcGVydHkgYnkgdGhpcyBuYW1lLCB0aGV5IHdpbGwgYmUgY29uc2lkZXJlZCB0b2tlbnMsIGFuZCB0aGlzXG4gKiBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byByZXNvbHZlIHRoZSB2YWx1ZSBmb3IgdGhpcyBvYmplY3QuXG4gKi9cbmV4cG9ydCBjb25zdCBSRVNPTFZFX01FVEhPRCA9ICdyZXNvbHZlJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3BlY2lhbCBvciBsYXppbHktZXZhbHVhdGVkIHZhbHVlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIGRlbGF5IGV2YWx1YXRpb24gb2YgYSBjZXJ0YWluIHZhbHVlIGluIGNhc2UsIGZvciBleGFtcGxlLFxuICogdGhhdCBpdCByZXF1aXJlcyBzb21lIGNvbnRleHQgb3IgbGF0ZS1ib3VuZCBkYXRhLiBDYW4gYWxzbyBiZSB1c2VkIHRvXG4gKiBtYXJrIHZhbHVlcyB0aGF0IG5lZWQgc3BlY2lhbCBwcm9jZXNzaW5nIGF0IGRvY3VtZW50IHJlbmRlcmluZyB0aW1lLlxuICpcbiAqIFRva2VucyBjYW4gYmUgZW1iZWRkZWQgaW50byBzdHJpbmdzIHdoaWxlIHJldGFpbmluZyB0aGVpciBvcmlnaW5hbFxuICogc2VtYW50aWNzLlxuICovXG5leHBvcnQgY2xhc3MgVG9rZW4ge1xuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIHRva2VuIChpLmUuIGhhcyB0aGUgcmVzb2x2ZSgpIG1ldGhvZCBvciBpcyBhIHN0cmluZ1xuICAgKiB0aGF0IGluY2x1ZGVzIHRva2VuIG1hcmtlcnMpLCBvciBpdCdzIGEgbGlzdGlmaWN0YWlvbiBvZiBhIFRva2VuIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHVucmVzb2x2ZWQob2JqOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdW5yZXNvbHZlZChvYmopO1xuICB9XG5cbiAgcHJpdmF0ZSB0b2tlblN0cmluZ2lmaWNhdGlvbj86IHN0cmluZztcbiAgcHJpdmF0ZSB0b2tlbkxpc3RpZmljYXRpb24/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRva2VuIHRoYXQgcmVzb2x2ZXMgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCB1cG9uIHJlc29sdXRpb24gYW5kXG4gICAqIHRoZSB2YWx1ZSBpdCByZXR1cm5zIHdpbGwgYmUgdXNlZCBhcyB0aGUgdG9rZW4ncyB2YWx1ZS5cbiAgICpcbiAgICogZGlzcGxheU5hbWUgaXMgdXNlZCB0byByZXByZXNlbnQgdGhlIFRva2VuIHdoZW4gaXQncyBlbWJlZGRlZCBpbnRvIGEgc3RyaW5nOyBpdFxuICAgKiB3aWxsIGxvb2sgc29tZXRoaW5nIGxpa2UgdGhpczpcbiAgICpcbiAgICogICAgXCJlbWJlZGRlZCBpbiBhIGxhcmdlciBzdHJpbmcgaXMgJHtUb2tlbltESVNQTEFZX05BTUUuMTIzXX1cIlxuICAgKlxuICAgKiBUaGlzIHZhbHVlIGlzIHVzZWQgYXMgYSBoaW50IHRvIGh1bWFucyB3aGF0IHRoZSBtZWFuaW5nIG9mIHRoZSBUb2tlbiBpcyxcbiAgICogYW5kIGRvZXMgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB0aGUgZXZhbHVhdGlvbi5cbiAgICpcbiAgICogTXVzdCBjb250YWluIG9ubHkgYWxwaGFudW1lcmljIGFuZCBzaW1wbGUgc2VwYXJhdG9yIGNoYXJhY3RlcnMgKF8uOi0pLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVPckZ1bmN0aW9uIFdoYXQgdGhpcyB0b2tlbiB3aWxsIGV2YWx1YXRlIHRvLCBsaXRlcmFsIG9yIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gZGlzcGxheU5hbWUgQSBodW1hbi1yZWFkYWJsZSBkaXNwbGF5IGhpbnQgZm9yIHRoaXMgVG9rZW5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgdmFsdWVPckZ1bmN0aW9uPzogYW55LCBwcml2YXRlIHJlYWRvbmx5IGRpc3BsYXlOYW1lPzogc3RyaW5nKSB7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgVGhlIHJlc29sdmVkIHZhbHVlIGZvciB0aGlzIHRva2VuLlxuICAgKi9cbiAgcHVibGljIHJlc29sdmUoX2NvbnRleHQ6IFJlc29sdmVDb250ZXh0KTogYW55IHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnZhbHVlT3JGdW5jdGlvbjtcbiAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSByZXZlcnNpYmxlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRva2VuXG4gICAqXG4gICAqIElmIHRoZSBUb2tlbiBpcyBpbml0aWFsaXplZCB3aXRoIGEgbGl0ZXJhbCwgdGhlIHN0cmluZ2lmaWVkIHZhbHVlIG9mIHRoZVxuICAgKiBsaXRlcmFsIGlzIHJldHVybmVkLiBPdGhlcndpc2UsIGEgc3BlY2lhbCBxdW90ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAqIG9mIHRoZSBUb2tlbiBpcyByZXR1cm5lZCB0aGF0IGNhbiBiZSBlbWJlZGRlZCBpbnRvIG90aGVyIHN0cmluZ3MuXG4gICAqXG4gICAqIFN0cmluZ3Mgd2l0aCBxdW90ZWQgVG9rZW5zIGluIHRoZW0gY2FuIGJlIHJlc3RvcmVkIGJhY2sgaW50b1xuICAgKiBjb21wbGV4IHZhbHVlcyB3aXRoIHRoZSBUb2tlbnMgcmVzdG9yZWQgYnkgY2FsbGluZyBgcmVzb2x2ZSgpYFxuICAgKiBvbiB0aGUgc3RyaW5nLlxuICAgKi9cbiAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIHRoaXMudmFsdWVPckZ1bmN0aW9uO1xuICAgIC8vIE9wdGltaXphdGlvbjogaWYgd2UgY2FuIGltbWVkaWF0ZWx5IHJlc29sdmUgdGhpcywgZG9uJ3QgYm90aGVyXG4gICAgLy8gcmVnaXN0ZXJpbmcgYSBUb2tlbi5cbiAgICBpZiAodmFsdWVUeXBlID09PSAnc3RyaW5nJyB8fCB2YWx1ZVR5cGUgPT09ICdudW1iZXInIHx8IHZhbHVlVHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZU9yRnVuY3Rpb24udG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlblN0cmluZ2lmaWNhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRva2VuU3RyaW5naWZpY2F0aW9uID0gVE9LRU5fTUFQLnJlZ2lzdGVyU3RyaW5nKHRoaXMsIHRoaXMuZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b2tlblN0cmluZ2lmaWNhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUdXJuIHRoaXMgVG9rZW4gaW50byBKU09OXG4gICAqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgYnkgSlNPTi5zdHJpbmdpZnkoKS4gV2Ugd2FudCB0byBwcm9oaWJpdCB0aGlzLCBiZWNhdXNlXG4gICAqIGl0J3Mgbm90IHBvc3NpYmxlIHRvIGRvIHRoaXMgcHJvcGVybHksIHNvIHdlIGp1c3QgdGhyb3cgYW4gZXJyb3IgaGVyZS5cbiAgICovXG4gIHB1YmxpYyB0b0pTT04oKTogYW55IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgdGhyb3cgbmV3IEVycm9yKCdKU09OLnN0cmluZ2lmeSgpIGNhbm5vdCBiZSBhcHBsaWVkIHRvIHN0cnVjdHVyZSB3aXRoIGEgVG9rZW4gaW4gaXQuIFVzZSB0aGlzLm5vZGUuc3RyaW5naWZ5SnNvbigpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgc3RyaW5nIGxpc3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0b2tlblxuICAgKlxuICAgKiBDYWxsIHRoaXMgaWYgdGhlIFRva2VuIGludHJpbnNpY2FsbHkgZXZhbHVhdGVzIHRvIGEgbGlzdCBvZiBzdHJpbmdzLlxuICAgKiBJZiBzbywgeW91IGNhbiByZXByZXNlbnQgdGhlIFRva2VuIGluIGEgc2ltaWxhciB3YXkgaW4gdGhlIHR5cGVcbiAgICogc3lzdGVtLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgZXZlbiB0aG91Z2ggdGhlIFRva2VuIGlzIHJlcHJlc2VudGVkIGFzIGEgbGlzdCBvZiBzdHJpbmdzLCB5b3VcbiAgICogc3RpbGwgY2Fubm90IGRvIGFueSBvcGVyYXRpb25zIG9uIGl0IHN1Y2ggYXMgY29uY2F0ZW5hdGlvbiwgaW5kZXhpbmcsXG4gICAqIG9yIHRha2luZyBpdHMgbGVuZ3RoLiBUaGUgb25seSB1c2VmdWwgb3BlcmF0aW9ucyB5b3UgY2FuIGRvIHRvIHRoZXNlIGxpc3RzXG4gICAqIGlzIGNvbnN0cnVjdGluZyBhIGBGbkpvaW5gIG9yIGEgYEZuU2VsZWN0YCBvbiBpdC5cbiAgICovXG4gIHB1YmxpYyB0b0xpc3QoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlT3JGdW5jdGlvbjtcbiAgICBpZiAodmFsdWVUeXBlID09PSAnc3RyaW5nJyB8fCB2YWx1ZVR5cGUgPT09ICdudW1iZXInIHx8IHZhbHVlVHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvdCBhIGxpdGVyYWwgVG9rZW4gdmFsdWU7IG9ubHkgaW50cmluc2ljcyBjYW4gZXZlciBldmFsdWF0ZSB0byBsaXN0cy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbkxpc3RpZmljYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50b2tlbkxpc3RpZmljYXRpb24gPSBUT0tFTl9NQVAucmVnaXN0ZXJMaXN0KHRoaXMsIHRoaXMuZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b2tlbkxpc3RpZmljYXRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBDdXJyZW50IHJlc29sdXRpb24gY29udGV4dCBmb3IgdG9rZW5zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2ZUNvbnRleHQge1xuICByZWFkb25seSBzY29wZTogSUNvbnN0cnVjdDtcbiAgcmVhZG9ubHkgcHJlZml4OiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBBIFRva2VuIHRoYXQgY2FuIHBvc3QtcHJvY2VzcyB0aGUgY29tcGxldGUgcmVzb2x2ZWQgdmFsdWUsIGFmdGVyIHJlc29sdmUoKSBoYXMgcmVjdXJzZWQgb3ZlciBpdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIElSZXNvbHZlZFZhbHVlUG9zdFByb2Nlc3NvciB7XG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBjb21wbGV0ZWx5IHJlc29sdmVkIHZhbHVlLCBhZnRlciBmdWxsIHJlY3Vyc2lvbi9yZXNvbHV0aW9uIGhhcyBoYXBwZW5lZFxuICAgKi9cbiAgcG9zdFByb2Nlc3MoaW5wdXQ6IGFueSwgY29udGV4dDogUmVzb2x2ZUNvbnRleHQpOiBhbnk7XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGBJUmVzb2x2ZWRWYWx1ZVBvc3RQcm9jZXNzb3JgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc29sdmVkVmFsdWVQb3N0UHJvY2Vzc29yKHg6IGFueSk6IHggaXMgSVJlc29sdmVkVmFsdWVQb3N0UHJvY2Vzc29yIHtcbiAgcmV0dXJuIHgucG9zdFByb2Nlc3MgIT09IHVuZGVmaW5lZDtcbn0iXX0=