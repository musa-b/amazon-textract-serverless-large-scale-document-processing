"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const resolve_1 = require("./resolve");
const unresolved_1 = require("./unresolved");
// Encoding Tokens into native types; should not be exported
/**
 * Central place where we keep a mapping from Tokens to their String representation
 *
 * The string representation is used to embed token into strings,
 * and stored to be able to
 *
 * All instances of TokenStringMap share the same storage, so that this process
 * works even when different copies of the library are loaded.
 */
class TokenMap {
    constructor() {
        this.tokenMap = new Map();
    }
    /**
     * Generate a unique string for this Token, returning a key
     *
     * Every call for the same Token will produce a new unique string, no
     * attempt is made to deduplicate. Token objects should cache the
     * value themselves, if required.
     *
     * The token can choose (part of) its own representation string with a
     * hint. This may be used to produce aesthetically pleasing and
     * recognizable token representations for humans.
     */
    registerString(token, representationHint) {
        const key = this.register(token, representationHint);
        return `${BEGIN_STRING_TOKEN_MARKER}${key}${END_TOKEN_MARKER}`;
    }
    /**
     * Generate a unique string for this Token, returning a key
     */
    registerList(token, representationHint) {
        const key = this.register(token, representationHint);
        return [`${BEGIN_LIST_TOKEN_MARKER}${key}${END_TOKEN_MARKER}`];
    }
    /**
     * Returns a `TokenString` for this string.
     */
    createStringTokenString(s) {
        return new TokenString(s, QUOTED_BEGIN_STRING_TOKEN_MARKER, `[${VALID_KEY_CHARS}]+`, QUOTED_END_TOKEN_MARKER);
    }
    /**
     * Returns a `TokenString` for this string.
     */
    createListTokenString(s) {
        return new TokenString(s, QUOTED_BEGIN_LIST_TOKEN_MARKER, `[${VALID_KEY_CHARS}]+`, QUOTED_END_TOKEN_MARKER);
    }
    /**
     * Replace any Token markers in this string with their resolved values
     */
    resolveStringTokens(s, context) {
        const str = this.createStringTokenString(s);
        const fragments = str.split(this.lookupToken.bind(this));
        // require() here to break cyclic dependencies
        const ret = fragments.mapUnresolved(x => resolve_1.resolve(x, context)).join(require('./cfn-concat').cloudFormationConcat);
        if (unresolved_1.unresolved(ret)) {
            return resolve_1.resolve(ret, context);
        }
        return ret;
    }
    resolveListTokens(xs, context) {
        // Must be a singleton list token, because concatenation is not allowed.
        if (xs.length !== 1) {
            throw new Error(`Cannot add elements to list token, got: ${xs}`);
        }
        const str = this.createListTokenString(xs[0]);
        const fragments = str.split(this.lookupToken.bind(this));
        if (fragments.length !== 1) {
            throw new Error(`Cannot concatenate strings in a tokenized string array, got: ${xs[0]}`);
        }
        return fragments.mapUnresolved(x => resolve_1.resolve(x, context)).values[0];
    }
    /**
     * Find a Token by key
     */
    lookupToken(key) {
        const token = this.tokenMap.get(key);
        if (!token) {
            throw new Error(`Unrecognized token key: ${key}`);
        }
        return token;
    }
    register(token, representationHint) {
        const counter = this.tokenMap.size;
        const representation = (representationHint || `TOKEN`).replace(new RegExp(`[^${VALID_KEY_CHARS}]`, 'g'), '.');
        const key = `${representation}.${counter}`;
        this.tokenMap.set(key, token);
        return key;
    }
}
exports.TokenMap = TokenMap;
const BEGIN_STRING_TOKEN_MARKER = '${Token[';
const BEGIN_LIST_TOKEN_MARKER = '#{Token[';
const END_TOKEN_MARKER = ']}';
const QUOTED_BEGIN_STRING_TOKEN_MARKER = regexQuote(BEGIN_STRING_TOKEN_MARKER);
const QUOTED_BEGIN_LIST_TOKEN_MARKER = regexQuote(BEGIN_LIST_TOKEN_MARKER);
const QUOTED_END_TOKEN_MARKER = regexQuote(END_TOKEN_MARKER);
const VALID_KEY_CHARS = 'a-zA-Z0-9:._-';
/**
 * A string with markers in it that can be resolved to external values
 */
class TokenString {
    constructor(str, quotedBeginMarker, idPattern, quotedEndMarker) {
        this.str = str;
        this.pattern = `${quotedBeginMarker}(${idPattern})${quotedEndMarker}`;
    }
    /**
     * Split string on markers, substituting markers with Tokens
     */
    split(lookup) {
        const re = new RegExp(this.pattern, 'g');
        const ret = new TokenizedStringFragments();
        let rest = 0;
        let m = re.exec(this.str);
        while (m) {
            if (m.index > rest) {
                ret.addLiteral(this.str.substring(rest, m.index));
            }
            ret.addUnresolved(lookup(m[1]));
            rest = re.lastIndex;
            m = re.exec(this.str);
        }
        if (rest < this.str.length) {
            ret.addLiteral(this.str.substring(rest));
        }
        return ret;
    }
    /**
     * Indicates if this string includes tokens.
     */
    test() {
        const re = new RegExp(this.pattern, 'g');
        return re.test(this.str);
    }
}
/**
 * Fragments of a string with markers
 */
class TokenizedStringFragments {
    constructor() {
        this.fragments = new Array();
    }
    get length() {
        return this.fragments.length;
    }
    get values() {
        return this.fragments.map(f => f.type === 'unresolved' ? f.token : f.lit);
    }
    addLiteral(lit) {
        this.fragments.push({ type: 'literal', lit });
    }
    addUnresolved(token) {
        this.fragments.push({ type: 'unresolved', token });
    }
    mapUnresolved(fn) {
        const ret = new TokenizedStringFragments();
        for (const f of this.fragments) {
            switch (f.type) {
                case 'literal':
                    ret.addLiteral(f.lit);
                    break;
                case 'unresolved':
                    const mappedToken = fn(f.token);
                    if (unresolved_1.unresolved(mappedToken)) {
                        ret.addUnresolved(mappedToken);
                    }
                    else {
                        ret.addLiteral(mappedToken);
                    }
                    break;
            }
        }
        return ret;
    }
    /**
     * Combine the resolved string fragments using the Tokens to join.
     *
     * Resolves the result.
     */
    join(concat) {
        if (this.fragments.length === 0) {
            return concat(undefined, undefined);
        }
        const values = this.fragments.map(fragmentValue);
        while (values.length > 1) {
            const prefix = values.splice(0, 2);
            values.splice(0, 0, concat(prefix[0], prefix[1]));
        }
        return values[0];
    }
}
/**
 * Resolve the value from a single fragment
 */
function fragmentValue(fragment) {
    return fragment.type === 'literal' ? fragment.lit : fragment.token;
}
/**
 * Quote a string for use in a regex
 */
function regexQuote(s) {
    return s.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const glob = global;
/**
 * Singleton instance of the token string map
 */
exports.TOKEN_MAP = glob.__cdkTokenMap = glob.__cdkTokenMap || new TokenMap();
function isListToken(x) {
    return typeof (x) === 'string' && exports.TOKEN_MAP.createListTokenString(x).test();
}
exports.isListToken = isListToken;
function containsListToken(xs) {
    return xs.some(isListToken);
}
exports.containsListToken = containsListToken;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jb2RpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJlbmNvZGluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHVDQUFvQztBQUVwQyw2Q0FBMEM7QUFFMUMsNERBQTREO0FBRTVEOzs7Ozs7OztHQVFHO0FBQ0gsTUFBYSxRQUFRO0lBQXJCO1FBQ21CLGFBQVEsR0FBRyxJQUFJLEdBQUcsRUFBaUIsQ0FBQztJQXNGdkQsQ0FBQztJQXBGQzs7Ozs7Ozs7OztPQVVHO0lBQ0ksY0FBYyxDQUFDLEtBQVksRUFBRSxrQkFBMkI7UUFDN0QsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztRQUNyRCxPQUFPLEdBQUcseUJBQXlCLEdBQUcsR0FBRyxHQUFHLGdCQUFnQixFQUFFLENBQUM7SUFDakUsQ0FBQztJQUVEOztPQUVHO0lBQ0ksWUFBWSxDQUFDLEtBQVksRUFBRSxrQkFBMkI7UUFDM0QsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztRQUNyRCxPQUFPLENBQUMsR0FBRyx1QkFBdUIsR0FBRyxHQUFHLEdBQUcsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRDs7T0FFRztJQUNJLHVCQUF1QixDQUFDLENBQVM7UUFDdEMsT0FBTyxJQUFJLFdBQVcsQ0FBQyxDQUFDLEVBQUUsZ0NBQWdDLEVBQUUsSUFBSSxlQUFlLElBQUksRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO0lBQ2hILENBQUM7SUFFRDs7T0FFRztJQUNJLHFCQUFxQixDQUFDLENBQVM7UUFDcEMsT0FBTyxJQUFJLFdBQVcsQ0FBQyxDQUFDLEVBQUUsOEJBQThCLEVBQUUsSUFBSSxlQUFlLElBQUksRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO0lBQzlHLENBQUM7SUFFRDs7T0FFRztJQUNJLG1CQUFtQixDQUFDLENBQVMsRUFBRSxPQUF1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QyxPQUFPLFFBQVEsQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO0FBQ3JFLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsVUFBVSxDQUFDLENBQVM7SUFDM0IsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLHNCQUFzQixFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ25ELENBQUM7QUFPRCxNQUFNLElBQUksR0FBRyxNQUFhLENBQUM7QUFFM0I7O0dBRUc7QUFDVSxRQUFBLFNBQVMsR0FBYSxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxRQUFRLEVBQUUsQ0FBQztBQUU3RixTQUFnQixXQUFXLENBQUMsQ0FBTTtJQUM5QixPQUFPLE9BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLElBQUksaUJBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUMvRSxDQUFDO0FBRkQsa0NBRUM7QUFFRCxTQUFnQixpQkFBaUIsQ0FBQyxFQUFTO0lBQ3pDLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUM5QixDQUFDO0FBRkQsOENBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNvbHZlIH0gZnJvbSBcIi4vcmVzb2x2ZVwiO1xuaW1wb3J0IHsgUmVzb2x2ZUNvbnRleHQsIFRva2VuIH0gZnJvbSBcIi4vdG9rZW5cIjtcbmltcG9ydCB7IHVucmVzb2x2ZWQgfSBmcm9tIFwiLi91bnJlc29sdmVkXCI7XG5cbi8vIEVuY29kaW5nIFRva2VucyBpbnRvIG5hdGl2ZSB0eXBlczsgc2hvdWxkIG5vdCBiZSBleHBvcnRlZFxuXG4vKipcbiAqIENlbnRyYWwgcGxhY2Ugd2hlcmUgd2Uga2VlcCBhIG1hcHBpbmcgZnJvbSBUb2tlbnMgdG8gdGhlaXIgU3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKlxuICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBpcyB1c2VkIHRvIGVtYmVkIHRva2VuIGludG8gc3RyaW5ncyxcbiAqIGFuZCBzdG9yZWQgdG8gYmUgYWJsZSB0b1xuICpcbiAqIEFsbCBpbnN0YW5jZXMgb2YgVG9rZW5TdHJpbmdNYXAgc2hhcmUgdGhlIHNhbWUgc3RvcmFnZSwgc28gdGhhdCB0aGlzIHByb2Nlc3NcbiAqIHdvcmtzIGV2ZW4gd2hlbiBkaWZmZXJlbnQgY29waWVzIG9mIHRoZSBsaWJyYXJ5IGFyZSBsb2FkZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUb2tlbk1hcCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgdG9rZW5NYXAgPSBuZXcgTWFwPHN0cmluZywgVG9rZW4+KCk7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdW5pcXVlIHN0cmluZyBmb3IgdGhpcyBUb2tlbiwgcmV0dXJuaW5nIGEga2V5XG4gICAqXG4gICAqIEV2ZXJ5IGNhbGwgZm9yIHRoZSBzYW1lIFRva2VuIHdpbGwgcHJvZHVjZSBhIG5ldyB1bmlxdWUgc3RyaW5nLCBub1xuICAgKiBhdHRlbXB0IGlzIG1hZGUgdG8gZGVkdXBsaWNhdGUuIFRva2VuIG9iamVjdHMgc2hvdWxkIGNhY2hlIHRoZVxuICAgKiB2YWx1ZSB0aGVtc2VsdmVzLCBpZiByZXF1aXJlZC5cbiAgICpcbiAgICogVGhlIHRva2VuIGNhbiBjaG9vc2UgKHBhcnQgb2YpIGl0cyBvd24gcmVwcmVzZW50YXRpb24gc3RyaW5nIHdpdGggYVxuICAgKiBoaW50LiBUaGlzIG1heSBiZSB1c2VkIHRvIHByb2R1Y2UgYWVzdGhldGljYWxseSBwbGVhc2luZyBhbmRcbiAgICogcmVjb2duaXphYmxlIHRva2VuIHJlcHJlc2VudGF0aW9ucyBmb3IgaHVtYW5zLlxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyU3RyaW5nKHRva2VuOiBUb2tlbiwgcmVwcmVzZW50YXRpb25IaW50Pzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnJlZ2lzdGVyKHRva2VuLCByZXByZXNlbnRhdGlvbkhpbnQpO1xuICAgIHJldHVybiBgJHtCRUdJTl9TVFJJTkdfVE9LRU5fTUFSS0VSfSR7a2V5fSR7RU5EX1RPS0VOX01BUktFUn1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdW5pcXVlIHN0cmluZyBmb3IgdGhpcyBUb2tlbiwgcmV0dXJuaW5nIGEga2V5XG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXJMaXN0KHRva2VuOiBUb2tlbiwgcmVwcmVzZW50YXRpb25IaW50Pzogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGtleSA9IHRoaXMucmVnaXN0ZXIodG9rZW4sIHJlcHJlc2VudGF0aW9uSGludCk7XG4gICAgcmV0dXJuIFtgJHtCRUdJTl9MSVNUX1RPS0VOX01BUktFUn0ke2tleX0ke0VORF9UT0tFTl9NQVJLRVJ9YF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGBUb2tlblN0cmluZ2AgZm9yIHRoaXMgc3RyaW5nLlxuICAgKi9cbiAgcHVibGljIGNyZWF0ZVN0cmluZ1Rva2VuU3RyaW5nKHM6IHN0cmluZykge1xuICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcocywgUVVPVEVEX0JFR0lOX1NUUklOR19UT0tFTl9NQVJLRVIsIGBbJHtWQUxJRF9LRVlfQ0hBUlN9XStgLCBRVU9URURfRU5EX1RPS0VOX01BUktFUik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGBUb2tlblN0cmluZ2AgZm9yIHRoaXMgc3RyaW5nLlxuICAgKi9cbiAgcHVibGljIGNyZWF0ZUxpc3RUb2tlblN0cmluZyhzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHMsIFFVT1RFRF9CRUdJTl9MSVNUX1RPS0VOX01BUktFUiwgYFske1ZBTElEX0tFWV9DSEFSU31dK2AsIFFVT1RFRF9FTkRfVE9LRU5fTUFSS0VSKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIGFueSBUb2tlbiBtYXJrZXJzIGluIHRoaXMgc3RyaW5nIHdpdGggdGhlaXIgcmVzb2x2ZWQgdmFsdWVzXG4gICAqL1xuICBwdWJsaWMgcmVzb2x2ZVN0cmluZ1Rva2VucyhzOiBzdHJpbmcsIGNvbnRleHQ6IFJlc29sdmVDb250ZXh0KTogYW55IHtcbiAgICBjb25zdCBzdHIgPSB0aGlzLmNyZWF0ZVN0cmluZ1Rva2VuU3RyaW5nKHMpO1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IHN0ci5zcGxpdCh0aGlzLmxvb2t1cFRva2VuLmJpbmQodGhpcykpO1xuICAgIC8vIHJlcXVpcmUoKSBoZXJlIHRvIGJyZWFrIGN5Y2xpYyBkZXBlbmRlbmNpZXNcbiAgICBjb25zdCByZXQgPSBmcmFnbWVudHMubWFwVW5yZXNvbHZlZCh4ID0+IHJlc29sdmUoeCwgY29udGV4dCkpLmpvaW4ocmVxdWlyZSgnLi9jZm4tY29uY2F0JykuY2xvdWRGb3JtYXRpb25Db25jYXQpO1xuICAgIGlmICh1bnJlc29sdmVkKHJldCkpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKHJldCwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBwdWJsaWMgcmVzb2x2ZUxpc3RUb2tlbnMoeHM6IHN0cmluZ1tdLCBjb250ZXh0OiBSZXNvbHZlQ29udGV4dCk6IGFueSB7XG4gICAgLy8gTXVzdCBiZSBhIHNpbmdsZXRvbiBsaXN0IHRva2VuLCBiZWNhdXNlIGNvbmNhdGVuYXRpb24gaXMgbm90IGFsbG93ZWQuXG4gICAgaWYgKHhzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYWRkIGVsZW1lbnRzIHRvIGxpc3QgdG9rZW4sIGdvdDogJHt4c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHIgPSB0aGlzLmNyZWF0ZUxpc3RUb2tlblN0cmluZyh4c1swXSk7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gc3RyLnNwbGl0KHRoaXMubG9va3VwVG9rZW4uYmluZCh0aGlzKSk7XG4gICAgaWYgKGZyYWdtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbmNhdGVuYXRlIHN0cmluZ3MgaW4gYSB0b2tlbml6ZWQgc3RyaW5nIGFycmF5LCBnb3Q6ICR7eHNbMF19YCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudHMubWFwVW5yZXNvbHZlZCh4ID0+IHJlc29sdmUoeCwgY29udGV4dCkpLnZhbHVlc1swXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGEgVG9rZW4gYnkga2V5XG4gICAqL1xuICBwdWJsaWMgbG9va3VwVG9rZW4oa2V5OiBzdHJpbmcpOiBUb2tlbiB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLnRva2VuTWFwLmdldChrZXkpO1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIHRva2VuIGtleTogJHtrZXl9YCk7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIHByaXZhdGUgcmVnaXN0ZXIodG9rZW46IFRva2VuLCByZXByZXNlbnRhdGlvbkhpbnQ/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvdW50ZXIgPSB0aGlzLnRva2VuTWFwLnNpemU7XG4gICAgY29uc3QgcmVwcmVzZW50YXRpb24gPSAocmVwcmVzZW50YXRpb25IaW50IHx8IGBUT0tFTmApLnJlcGxhY2UobmV3IFJlZ0V4cChgW14ke1ZBTElEX0tFWV9DSEFSU31dYCwgJ2cnKSwgJy4nKTtcbiAgICBjb25zdCBrZXkgPSBgJHtyZXByZXNlbnRhdGlvbn0uJHtjb3VudGVyfWA7XG4gICAgdGhpcy50b2tlbk1hcC5zZXQoa2V5LCB0b2tlbik7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxufVxuXG5jb25zdCBCRUdJTl9TVFJJTkdfVE9LRU5fTUFSS0VSID0gJyR7VG9rZW5bJztcbmNvbnN0IEJFR0lOX0xJU1RfVE9LRU5fTUFSS0VSID0gJyN7VG9rZW5bJztcbmNvbnN0IEVORF9UT0tFTl9NQVJLRVIgPSAnXX0nO1xuXG5jb25zdCBRVU9URURfQkVHSU5fU1RSSU5HX1RPS0VOX01BUktFUiA9IHJlZ2V4UXVvdGUoQkVHSU5fU1RSSU5HX1RPS0VOX01BUktFUik7XG5jb25zdCBRVU9URURfQkVHSU5fTElTVF9UT0tFTl9NQVJLRVIgPSByZWdleFF1b3RlKEJFR0lOX0xJU1RfVE9LRU5fTUFSS0VSKTtcbmNvbnN0IFFVT1RFRF9FTkRfVE9LRU5fTUFSS0VSID0gcmVnZXhRdW90ZShFTkRfVE9LRU5fTUFSS0VSKTtcblxuY29uc3QgVkFMSURfS0VZX0NIQVJTID0gJ2EtekEtWjAtOTouXy0nO1xuXG4vKipcbiAqIEludGVyZmFjZSB0aGF0IFRva2VuIGpvaW5lcnMgaW1wbGVtZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVRva2VuSm9pbmVyIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBqb2luZXIuXG4gICAqXG4gICAqIE11c3QgYmUgdW5pcXVlIHBlciBqb2luZXI6IHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkIHRvIGFzc2VydCB0aGF0IHRoZXJlXG4gICAqIGlzIGV4YWN0bHkgb25seSB0eXBlIG9mIGpvaW5lciBpbiBhIGpvaW4gb3BlcmF0aW9uLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsYW5ndWFnZSBpbnRyaW5zaWMgdGhhdCB3aWxsIGNvbWJpbmUgdGhlIHN0cmluZ3MgaW4gdGhlIGdpdmVuIGVuZ2luZVxuICAgKi9cbiAgam9pbihmcmFnbWVudHM6IGFueVtdKTogYW55O1xufVxuXG4vKipcbiAqIEEgc3RyaW5nIHdpdGggbWFya2VycyBpbiBpdCB0aGF0IGNhbiBiZSByZXNvbHZlZCB0byBleHRlcm5hbCB2YWx1ZXNcbiAqL1xuY2xhc3MgVG9rZW5TdHJpbmcge1xuICBwcml2YXRlIHBhdHRlcm46IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0cjogc3RyaW5nLFxuICAgIHF1b3RlZEJlZ2luTWFya2VyOiBzdHJpbmcsXG4gICAgaWRQYXR0ZXJuOiBzdHJpbmcsXG4gICAgcXVvdGVkRW5kTWFya2VyOiBzdHJpbmcpIHtcbiAgICB0aGlzLnBhdHRlcm4gPSBgJHtxdW90ZWRCZWdpbk1hcmtlcn0oJHtpZFBhdHRlcm59KSR7cXVvdGVkRW5kTWFya2VyfWA7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgc3RyaW5nIG9uIG1hcmtlcnMsIHN1YnN0aXR1dGluZyBtYXJrZXJzIHdpdGggVG9rZW5zXG4gICAqL1xuICBwdWJsaWMgc3BsaXQobG9va3VwOiAoaWQ6IHN0cmluZykgPT4gVG9rZW4pOiBUb2tlbml6ZWRTdHJpbmdGcmFnbWVudHMge1xuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cCh0aGlzLnBhdHRlcm4sICdnJyk7XG4gICAgY29uc3QgcmV0ID0gbmV3IFRva2VuaXplZFN0cmluZ0ZyYWdtZW50cygpO1xuXG4gICAgbGV0IHJlc3QgPSAwO1xuICAgIGxldCBtID0gcmUuZXhlYyh0aGlzLnN0cik7XG4gICAgd2hpbGUgKG0pIHtcbiAgICAgIGlmIChtLmluZGV4ID4gcmVzdCkge1xuICAgICAgICByZXQuYWRkTGl0ZXJhbCh0aGlzLnN0ci5zdWJzdHJpbmcocmVzdCwgbS5pbmRleCkpO1xuICAgICAgfVxuXG4gICAgICByZXQuYWRkVW5yZXNvbHZlZChsb29rdXAobVsxXSkpO1xuXG4gICAgICByZXN0ID0gcmUubGFzdEluZGV4O1xuICAgICAgbSA9IHJlLmV4ZWModGhpcy5zdHIpO1xuICAgIH1cblxuICAgIGlmIChyZXN0IDwgdGhpcy5zdHIubGVuZ3RoKSB7XG4gICAgICByZXQuYWRkTGl0ZXJhbCh0aGlzLnN0ci5zdWJzdHJpbmcocmVzdCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoaXMgc3RyaW5nIGluY2x1ZGVzIHRva2Vucy5cbiAgICovXG4gIHB1YmxpYyB0ZXN0KCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cCh0aGlzLnBhdHRlcm4sICdnJyk7XG4gICAgcmV0dXJuIHJlLnRlc3QodGhpcy5zdHIpO1xuICB9XG59XG5cbi8qKlxuICogUmVzdWx0IG9mIHRoZSBzcGxpdCBvZiBhIHN0cmluZyB3aXRoIFRva2Vuc1xuICpcbiAqIEVpdGhlciBhIGxpdGVyYWwgcGFydCBvZiB0aGUgc3RyaW5nLCBvciBhbiB1bnJlc29sdmVkIFRva2VuLlxuICovXG50eXBlIExpdGVyYWxGcmFnbWVudCA9IHsgdHlwZTogJ2xpdGVyYWwnOyBsaXQ6IGFueTsgfTtcbnR5cGUgVW5yZXNvbHZlZEZyYWdtZW50ID0geyB0eXBlOiAndW5yZXNvbHZlZCc7IHRva2VuOiBhbnk7IH07XG50eXBlIEZyYWdtZW50ID0gIExpdGVyYWxGcmFnbWVudCB8IFVucmVzb2x2ZWRGcmFnbWVudDtcblxuLyoqXG4gKiBGcmFnbWVudHMgb2YgYSBzdHJpbmcgd2l0aCBtYXJrZXJzXG4gKi9cbmNsYXNzIFRva2VuaXplZFN0cmluZ0ZyYWdtZW50cyB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZnJhZ21lbnRzID0gbmV3IEFycmF5PEZyYWdtZW50PigpO1xuXG4gIHB1YmxpYyBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZhbHVlcygpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRzLm1hcChmID0+IGYudHlwZSA9PT0gJ3VucmVzb2x2ZWQnID8gZi50b2tlbiA6IGYubGl0KTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRMaXRlcmFsKGxpdDogYW55KSB7XG4gICAgdGhpcy5mcmFnbWVudHMucHVzaCh7IHR5cGU6ICdsaXRlcmFsJywgbGl0IH0pO1xuICB9XG5cbiAgcHVibGljIGFkZFVucmVzb2x2ZWQodG9rZW46IFRva2VuKSB7XG4gICAgdGhpcy5mcmFnbWVudHMucHVzaCh7IHR5cGU6ICd1bnJlc29sdmVkJywgdG9rZW4gfSk7XG4gIH1cblxuICBwdWJsaWMgbWFwVW5yZXNvbHZlZChmbjogKHQ6IGFueSkgPT4gYW55KTogVG9rZW5pemVkU3RyaW5nRnJhZ21lbnRzIHtcbiAgICBjb25zdCByZXQgPSBuZXcgVG9rZW5pemVkU3RyaW5nRnJhZ21lbnRzKCk7XG5cbiAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5mcmFnbWVudHMpIHtcbiAgICAgIHN3aXRjaCAoZi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICAgIHJldC5hZGRMaXRlcmFsKGYubGl0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndW5yZXNvbHZlZCc6XG4gICAgICAgICAgY29uc3QgbWFwcGVkVG9rZW4gPSBmbihmLnRva2VuKTtcblxuICAgICAgICAgIGlmICh1bnJlc29sdmVkKG1hcHBlZFRva2VuKSkge1xuICAgICAgICAgICAgcmV0LmFkZFVucmVzb2x2ZWQobWFwcGVkVG9rZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQuYWRkTGl0ZXJhbChtYXBwZWRUb2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZSB0aGUgcmVzb2x2ZWQgc3RyaW5nIGZyYWdtZW50cyB1c2luZyB0aGUgVG9rZW5zIHRvIGpvaW4uXG4gICAqXG4gICAqIFJlc29sdmVzIHRoZSByZXN1bHQuXG4gICAqL1xuICBwdWJsaWMgam9pbihjb25jYXQ6IENvbmNhdEZ1bmMpOiBhbnkge1xuICAgIGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGggPT09IDApIHsgcmV0dXJuIGNvbmNhdCh1bmRlZmluZWQsIHVuZGVmaW5lZCk7IH1cblxuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuZnJhZ21lbnRzLm1hcChmcmFnbWVudFZhbHVlKTtcblxuICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgcHJlZml4ID0gdmFsdWVzLnNwbGljZSgwLCAyKTtcbiAgICAgIHZhbHVlcy5zcGxpY2UoMCwgMCwgY29uY2F0KHByZWZpeFswXSwgcHJlZml4WzFdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlc1swXTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc29sdmUgdGhlIHZhbHVlIGZyb20gYSBzaW5nbGUgZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gZnJhZ21lbnRWYWx1ZShmcmFnbWVudDogRnJhZ21lbnQpOiBhbnkge1xuICByZXR1cm4gZnJhZ21lbnQudHlwZSA9PT0gJ2xpdGVyYWwnID8gZnJhZ21lbnQubGl0IDogZnJhZ21lbnQudG9rZW47XG59XG5cbi8qKlxuICogUXVvdGUgYSBzdHJpbmcgZm9yIHVzZSBpbiBhIHJlZ2V4XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4UXVvdGUoczogc3RyaW5nKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgXCJcXFxcJCZcIik7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdXNlZCB0byBjb25jYXRlbmF0ZSBzeW1ib2xzIGluIHRoZSB0YXJnZXQgZG9jdW1lbnQgbGFuZ3VhZ2VcbiAqL1xuZXhwb3J0IHR5cGUgQ29uY2F0RnVuYyA9IChsZWZ0OiBhbnkgfCB1bmRlZmluZWQsIHJpZ2h0OiBhbnkgfCB1bmRlZmluZWQpID0+IGFueTtcblxuY29uc3QgZ2xvYiA9IGdsb2JhbCBhcyBhbnk7XG5cbi8qKlxuICogU2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSB0b2tlbiBzdHJpbmcgbWFwXG4gKi9cbmV4cG9ydCBjb25zdCBUT0tFTl9NQVA6IFRva2VuTWFwID0gZ2xvYi5fX2Nka1Rva2VuTWFwID0gZ2xvYi5fX2Nka1Rva2VuTWFwIHx8IG5ldyBUb2tlbk1hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMaXN0VG9rZW4oeDogYW55KSB7XG4gICAgcmV0dXJuIHR5cGVvZih4KSA9PT0gJ3N0cmluZycgJiYgVE9LRU5fTUFQLmNyZWF0ZUxpc3RUb2tlblN0cmluZyh4KS50ZXN0KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0xpc3RUb2tlbih4czogYW55W10pIHtcbiAgcmV0dXJuIHhzLnNvbWUoaXNMaXN0VG9rZW4pO1xufSJdfQ==