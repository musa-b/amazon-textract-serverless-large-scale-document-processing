import { Reference } from "./reference";
/**
 * A Token that represents a CloudFormation reference to another resource
 *
 * If these references are used in a different stack from where they are
 * defined, appropriate CloudFormation `Export`s and `Fn::ImportValue`s will be
 * synthesized automatically instead of the regular CloudFormation references.
 *
 * Additionally, the dependency between the stacks will be recorded, and the toolkit
 * will make sure to deploy producing stack before the consuming stack.
 *
 * This magic happens in the prepare() phase, where consuming stacks will call
 * `consumeFromStack` on these Tokens and if they happen to be exported by a different
 * Stack, we'll register the dependency.
 */
export declare class CfnReference extends Reference {
    /**
     * Check whether this is actually a Reference
     */
    static isCfnReference(x: Token): x is CfnReference;
    /**
     * What stack this Token is pointing to
     */
    private readonly producingStack?;
    /**
     * The Tokens that should be returned for each consuming stack (as decided by the producing Stack)
     */
    private readonly replacementTokens;
    private readonly originalDisplayName;
    constructor(value: any, displayName: string, target: Construct);
    resolve(context: ResolveContext): any;
    /**
     * Register a stack this references is being consumed from.
     */
    consumeFromStack(consumingStack: Stack, consumingConstruct: IConstruct): void;
    /**
     * Export a Token value for use in another stack
     *
     * Works by mutating the producing stack in-place.
     */
    private exportValue;
}
import { Construct, IConstruct } from "./construct";
import { Stack } from "./stack";
import { ResolveContext, Token } from "./token";
