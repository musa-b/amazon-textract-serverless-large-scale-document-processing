"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AWS = require("aws-sdk");
const child_process = require("child_process");
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const util = require("util");
const logging_1 = require("../../logging");
const plugin_1 = require("../../plugin");
const account_cache_1 = require("./account-cache");
const sdk_ini_file_1 = require("./sdk_ini_file");
/**
 * Source for SDK client objects
 *
 * Credentials are first obtained from the SDK defaults (using environment variables and the
 * ~/.aws/{config,credentials} files).
 *
 * If those don't suffice, a list of CredentialProviderSources is interrogated for access
 * to the requested account.
 */
class SDK {
    constructor(options = {}) {
        /**
         * Default retry options for SDK clients
         *
         * Biggest bottleneck is CloudFormation, with a 1tps call rate. We want to be
         * a little more tenacious than the defaults, and with a little more breathing
         * room between calls (defaults are {retries=3, base=100}).
         *
         * I've left this running in a tight loop for an hour and the throttle errors
         * haven't escaped the retry mechanism.
         */
        this.retryOptions = { maxRetries: 6, retryDelayOptions: { base: 300 } };
        this.profile = options.profile;
        const defaultCredentialProvider = makeCLICompatibleCredentialProvider(options.profile, options.ec2creds);
        // Find the package.json from the main toolkit
        const pkg = require.main.require('../package.json');
        AWS.config.update({
            customUserAgent: `${pkg.name}/${pkg.version}`
        });
        // https://aws.amazon.com/blogs/developer/using-the-aws-sdk-for-javascript-from-behind-a-proxy/
        if (options.proxyAddress === undefined) {
            options.proxyAddress = httpsProxyFromEnvironment();
        }
        if (options.proxyAddress) { // Ignore empty string on purpose
            logging_1.debug('Using proxy server: %s', options.proxyAddress);
            AWS.config.update({
                httpOptions: { agent: require('proxy-agent')(options.proxyAddress) }
            });
        }
        this.defaultAwsAccount = new DefaultAWSAccount(defaultCredentialProvider, getCLICompatibleDefaultRegion(this.profile));
        this.credentialsCache = new CredentialsCache(this.defaultAwsAccount, defaultCredentialProvider);
    }
    async cloudFormation(environment, mode) {
        return new AWS.CloudFormation(Object.assign({}, this.retryOptions, { region: environment.region, credentials: await this.credentialsCache.get(environment.account, mode) }));
    }
    async ec2(awsAccountId, region, mode) {
        return new AWS.EC2(Object.assign({}, this.retryOptions, { region, credentials: await this.credentialsCache.get(awsAccountId, mode) }));
    }
    async ssm(awsAccountId, region, mode) {
        return new AWS.SSM(Object.assign({}, this.retryOptions, { region, credentials: await this.credentialsCache.get(awsAccountId, mode) }));
    }
    async s3(environment, mode) {
        return new AWS.S3(Object.assign({}, this.retryOptions, { region: environment.region, credentials: await this.credentialsCache.get(environment.account, mode) }));
    }
    async route53(awsAccountId, region, mode) {
        return new AWS.Route53(Object.assign({}, this.retryOptions, { region, credentials: await this.credentialsCache.get(awsAccountId, mode) }));
    }
    async ecr(environment, mode) {
        return new AWS.ECR(Object.assign({}, this.retryOptions, { region: environment.region, credentials: await this.credentialsCache.get(environment.account, mode) }));
    }
    async defaultRegion() {
        return await getCLICompatibleDefaultRegion(this.profile);
    }
    defaultAccount() {
        return this.defaultAwsAccount.get();
    }
}
exports.SDK = SDK;
/**
 * Cache for credential providers.
 *
 * Given an account and an operating mode (read or write) will return an
 * appropriate credential provider for credentials for the given account. The
 * credential provider will be cached so that multiple AWS clients for the same
 * environment will not make multiple network calls to obtain credentials.
 *
 * Will use default credentials if they are for the right account; otherwise,
 * all loaded credential provider plugins will be tried to obtain credentials
 * for the given account.
 */
class CredentialsCache {
    constructor(defaultAwsAccount, defaultCredentialProvider) {
        this.defaultAwsAccount = defaultAwsAccount;
        this.defaultCredentialProvider = defaultCredentialProvider;
        this.cache = {};
    }
    async get(awsAccountId, mode) {
        const key = `${awsAccountId}-${mode}`;
        if (!(key in this.cache)) {
            this.cache[key] = await this.getCredentials(awsAccountId, mode);
        }
        return this.cache[key];
    }
    async getCredentials(awsAccountId, mode) {
        // If requested account is undefined or equal to default account, use default credentials provider.
        // (Note that we ignore the mode in this case, if you preloaded credentials they better be correct!)
        const defaultAccount = await this.defaultAwsAccount.get();
        if (!awsAccountId || awsAccountId === defaultAccount) {
            logging_1.debug(`Using default AWS SDK credentials for account ${awsAccountId}`);
            // CredentialProviderChain extends Credentials, but that is a lie.
            // https://github.com/aws/aws-sdk-js/issues/2235
            // Call resolve() instead.
            return (await this.defaultCredentialProvider).resolvePromise();
        }
        const triedSources = [];
        // Otherwise, inspect the various credential sources we have
        for (const source of plugin_1.PluginHost.instance.credentialProviderSources) {
            if (!(await source.isAvailable())) {
                logging_1.debug('Credentials source %s is not available, ignoring it.', source.name);
                continue;
            }
            triedSources.push(source);
            if (!(await source.canProvideCredentials(awsAccountId))) {
                continue;
            }
            logging_1.debug(`Using ${source.name} credentials for account ${awsAccountId}`);
            const providerOrCreds = await source.getProvider(awsAccountId, mode);
            // Backwards compatibility: if the plugin returns a ProviderChain, resolve that chain.
            // Otherwise it must have returned credentials.
            if (providerOrCreds.resolvePromise) {
                return await providerOrCreds.resolvePromise();
            }
            return providerOrCreds;
        }
        const sourceNames = ['default credentials'].concat(triedSources.map(s => s.name)).join(', ');
        throw new Error(`Need to perform AWS calls for account ${awsAccountId}, but no credentials found. Tried: ${sourceNames}.`);
    }
}
/**
 * Class to retrieve the account for default credentials and cache it.
 *
 * Uses the default credentials provider to obtain credentials (if available),
 * and uses those credentials to call STS to request the current account ID.
 *
 * The credentials => accountId lookup is cached on disk, since it's
 * guaranteed that igven access key will always remain for the same account.
 */
class DefaultAWSAccount {
    constructor(defaultCredentialsProvider, region) {
        this.defaultCredentialsProvider = defaultCredentialsProvider;
        this.region = region;
        this.defaultAccountFetched = false;
        this.defaultAccountId = undefined;
        this.accountCache = new account_cache_1.AccountAccessKeyCache();
    }
    /**
     * Return the default account
     */
    async get() {
        if (!this.defaultAccountFetched) {
            this.defaultAccountId = await this.lookupDefaultAccount();
            this.defaultAccountFetched = true;
        }
        return this.defaultAccountId;
    }
    async lookupDefaultAccount() {
        try {
            // There just is *NO* way to do AssumeRole credentials as long as AWS_SDK_LOAD_CONFIG is not set. The SDK
            // crash if the file does not exist though. So set the environment variable if we can find that file.
            await setConfigVariable();
            logging_1.debug('Resolving default credentials');
            const credentialProvider = await this.defaultCredentialsProvider;
            const creds = await credentialProvider.resolvePromise();
            const accessKeyId = creds.accessKeyId;
            if (!accessKeyId) {
                throw new Error('Unable to resolve AWS credentials (setup with "aws configure")');
            }
            const accountId = await this.accountCache.fetch(creds.accessKeyId, async () => {
                // if we don't have one, resolve from STS and store in cache.
                logging_1.debug('Looking up default account ID from STS');
                const result = await new AWS.STS({ credentials: creds, region: await this.region }).getCallerIdentity().promise();
                const aid = result.Account;
                if (!aid) {
                    logging_1.debug('STS didn\'t return an account ID');
                    return undefined;
                }
                logging_1.debug('Default account ID:', aid);
                return aid;
            });
            return accountId;
        }
        catch (e) {
            logging_1.debug('Unable to determine the default AWS account (did you configure "aws configure"?):', e);
            return undefined;
        }
    }
}
/**
 * Build an AWS CLI-compatible credential chain provider
 *
 * This is similar to the default credential provider chain created by the SDK
 * except it also accepts the profile argument in the constructor (not just from
 * the environment).
 *
 * To mimic the AWS CLI behavior:
 *
 * - we default to ~/.aws/credentials if environment variable for credentials
 * file location is not given (SDK expects explicit environment variable with name).
 * - AWS_DEFAULT_PROFILE is also inspected for profile name (not just AWS_PROFILE).
 */
async function makeCLICompatibleCredentialProvider(profile, ec2creds) {
    profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
    // Need to construct filename ourselves, without appropriate environment variables
    // no defaults used by JS SDK.
    const filename = process.env.AWS_SHARED_CREDENTIALS_FILE || path.join(os.homedir(), '.aws', 'credentials');
    const sources = [
        () => new AWS.EnvironmentCredentials('AWS'),
        () => new AWS.EnvironmentCredentials('AMAZON'),
    ];
    if (fs.pathExists(filename)) {
        sources.push(() => new AWS.SharedIniFileCredentials({ profile, filename }));
    }
    if (hasEcsCredentials()) {
        sources.push(() => new AWS.ECSCredentials());
    }
    else {
        // else if: don't get EC2 creds if we should have gotten ECS creds--ECS instances also
        // run on EC2 boxes but the creds represent something different. Same behavior as
        // upstream code.
        if (ec2creds === undefined) {
            ec2creds = await hasEc2Credentials();
        }
        if (ec2creds) {
            sources.push(() => new AWS.EC2MetadataCredentials());
        }
    }
    return new AWS.CredentialProviderChain(sources);
}
/**
 * Return the default region in a CLI-compatible way
 *
 * Mostly copied from node_loader.js, but with the following differences:
 *
 * - Takes a runtime profile name to load the region from, not just based on environment
 *   variables at process start.
 * - We have needed to create a local copy of the SharedIniFile class because the
 *   implementation in 'aws-sdk' is private (and the default use of it in the
 *   SDK does not allow us to specify a profile at runtime).
 * - AWS_DEFAULT_PROFILE and AWS_DEFAULT_REGION are also used as environment
 *   variables to be used to determine the region.
 */
async function getCLICompatibleDefaultRegion(profile) {
    profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
    // Defaults inside constructor
    const toCheck = [
        { filename: process.env.AWS_SHARED_CREDENTIALS_FILE },
        { isConfig: true, filename: process.env.AWS_CONFIG_FILE },
    ];
    let region = process.env.AWS_REGION || process.env.AMAZON_REGION ||
        process.env.AWS_DEFAULT_REGION || process.env.AMAZON_DEFAULT_REGION;
    while (!region && toCheck.length > 0) {
        const configFile = new sdk_ini_file_1.SharedIniFile(toCheck.shift());
        const section = await configFile.getProfile(profile);
        region = section && section.region;
    }
    return region;
}
/**
 * Find and return the configured HTTPS proxy address
 */
function httpsProxyFromEnvironment() {
    if (process.env.https_proxy) {
        return process.env.https_proxy;
    }
    if (process.env.HTTPS_PROXY) {
        return process.env.HTTPS_PROXY;
    }
    return undefined;
}
/**
 * Return whether it looks like we'll have ECS credentials available
 */
function hasEcsCredentials() {
    return AWS.ECSCredentials.prototype.isConfiguredForEcsCredentials();
}
/**
 * Return whether we're on an EC2 instance
 */
async function hasEc2Credentials() {
    logging_1.debug("Determining whether we're on an EC2 instance.");
    let instance = false;
    if (process.platform === 'win32') {
        // https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/identify_ec2_instances.html
        const result = await util.promisify(child_process.exec)('wmic path win32_computersystemproduct get uuid', { encoding: 'utf-8' });
        // output looks like
        //  UUID
        //  EC2AE145-D1DC-13B2-94ED-01234ABCDEF
        const lines = result.stdout.toString().split('\n');
        instance = lines.some(x => matchesRegex(/^ec2/i, x));
    }
    else {
        // https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/identify_ec2_instances.html
        const files = [
            // This recognizes the Xen hypervisor based instances (pre-5th gen)
            ['/sys/hypervisor/uuid', /^ec2/i],
            // This recognizes the new Hypervisor (5th-gen instances and higher)
            // Can't use the advertised file '/sys/devices/virtual/dmi/id/product_uuid' because it requires root to read.
            // Instead, sys_vendor contains something like 'Amazon EC2'.
            ['/sys/devices/virtual/dmi/id/sys_vendor', /ec2/i],
        ];
        for (const [file, re] of files) {
            if (matchesRegex(re, await readIfPossible(file))) {
                instance = true;
                break;
            }
        }
    }
    logging_1.debug(instance ? 'Looks like EC2 instance.' : 'Does not look like EC2 instance.');
    return instance;
}
async function setConfigVariable() {
    const homeDir = process.env.HOME || process.env.USERPROFILE
        || (process.env.HOMEPATH ? ((process.env.HOMEDRIVE || 'C:/') + process.env.HOMEPATH) : null) || os.homedir();
    if (await fs.pathExists(path.resolve(homeDir, '.aws', 'config'))) {
        process.env.AWS_SDK_LOAD_CONFIG = '1';
    }
}
async function readIfPossible(filename) {
    try {
        if (!await fs.pathExists(filename)) {
            return undefined;
        }
        return fs.readFile(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        logging_1.debug(e);
        return undefined;
    }
}
function matchesRegex(re, s) {
    return s !== undefined && re.exec(s) !== null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsK0JBQWdDO0FBQ2hDLCtDQUFnRDtBQUNoRCwrQkFBZ0M7QUFDaEMseUJBQTBCO0FBQzFCLDZCQUE4QjtBQUM5Qiw2QkFBOEI7QUFDOUIsMkNBQXNDO0FBQ3RDLHlDQUEwQztBQUUxQyxtREFBd0Q7QUFDeEQsaURBQStDO0FBMkIvQzs7Ozs7Ozs7R0FRRztBQUNILE1BQWEsR0FBRztJQWlCZCxZQUFZLFVBQXNCLEVBQUU7UUFacEM7Ozs7Ozs7OztXQVNHO1FBQ2MsaUJBQVksR0FBRyxFQUFFLFVBQVUsRUFBRSxDQUFDLEVBQUUsaUJBQWlCLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEVBQUMsQ0FBQztRQUdqRixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7UUFFL0IsTUFBTSx5QkFBeUIsR0FBRyxtQ0FBbUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUV6Ryw4Q0FBOEM7UUFDOUMsTUFBTSxHQUFHLEdBQUksT0FBTyxDQUFDLElBQVksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUM3RCxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztZQUNkLGVBQWUsRUFBRSxHQUFHLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRTtTQUNoRCxDQUFDLENBQUM7UUFFSCwrRkFBK0Y7UUFDL0YsSUFBSSxPQUFPLENBQUMsWUFBWSxLQUFLLFNBQVMsRUFBRTtZQUN0QyxPQUFPLENBQUMsWUFBWSxHQUFHLHlCQUF5QixFQUFFLENBQUM7U0FDcEQ7UUFDRCxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUUsRUFBRSxpQ0FBaUM7WUFDM0QsZUFBSyxDQUFDLHdCQUF3QixFQUFFLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztZ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RyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7SUFFL0csSUFBSSxNQUFNLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDLEVBQUU7UUFDaEUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsR0FBRyxHQUFHLENBQUM7S0FDdkM7QUFDSCxDQUFDO0FBRUQsS0FBSyxVQUFVLGNBQWMsQ0FBQyxRQUFnQjtJQUM1QyxJQUFJO1FBQ0YsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUFFLE9BQU8sU0FBUyxDQUFDO1NBQUU7UUFDekQsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0tBQ3JEO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixlQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDVCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtBQUNILENBQUM7QUFFRCxTQUFTLFlBQVksQ0FBQyxFQUFVLEVBQUUsQ0FBcUI7SUFDckQsT0FBTyxDQUFDLEtBQUssU0FBUyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDO0FBQ2hELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbnZpcm9ubWVudH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCBBV1MgPSByZXF1aXJlKCdhd3Mtc2RrJyk7XG5pbXBvcnQgY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcbmltcG9ydCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XG5pbXBvcnQgb3MgPSByZXF1aXJlKCdvcycpO1xuaW1wb3J0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5pbXBvcnQgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBQbHVnaW5Ib3N0IH0gZnJvbSAnLi4vLi4vcGx1Z2luJztcbmltcG9ydCB7IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZSwgTW9kZSB9IGZyb20gJy4uL2F3cy1hdXRoL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IEFjY291bnRBY2Nlc3NLZXlDYWNoZSB9IGZyb20gJy4vYWNjb3VudC1jYWNoZSc7XG5pbXBvcnQgeyBTaGFyZWRJbmlGaWxlIH0gZnJvbSAnLi9zZGtfaW5pX2ZpbGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNES09wdGlvbnMge1xuICAvKipcbiAgICogUHJvZmlsZSBuYW1lIHRvIHVzZVxuICAgKlxuICAgKiBAZGVmYXVsdCBObyBwcm9maWxlXG4gICAqL1xuICBwcm9maWxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQcm94eSBhZGRyZXNzIHRvIHVzZVxuICAgKlxuICAgKiBAZGVmYXVsdCBObyBwcm94eVxuICAgKi9cbiAgcHJveHlBZGRyZXNzPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIHNob3VsZCB0cnkgaW5zdGFuY2UgY3JlZGVudGlhbHNcbiAgICpcbiAgICogVHJ1ZS9mYWxzZSB0byBmb3JjZS9kaXNhYmxlLiBEZWZhdWx0IGlzIHRvIGd1ZXNzLlxuICAgKlxuICAgKiBAZGVmYXVsdCBBdXRvbWF0aWNhbGx5IGRldGVybWluZS5cbiAgICovXG4gIGVjMmNyZWRzPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBTb3VyY2UgZm9yIFNESyBjbGllbnQgb2JqZWN0c1xuICpcbiAqIENyZWRlbnRpYWxzIGFyZSBmaXJzdCBvYnRhaW5lZCBmcm9tIHRoZSBTREsgZGVmYXVsdHMgKHVzaW5nIGVudmlyb25tZW50IHZhcmlhYmxlcyBhbmQgdGhlXG4gKiB+Ly5hd3Mve2NvbmZpZyxjcmVkZW50aWFsc30gZmlsZXMpLlxuICpcbiAqIElmIHRob3NlIGRvbid0IHN1ZmZpY2UsIGEgbGlzdCBvZiBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VzIGlzIGludGVycm9nYXRlZCBmb3IgYWNjZXNzXG4gKiB0byB0aGUgcmVxdWVzdGVkIGFjY291bnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTREsge1xuICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRBd3NBY2NvdW50OiBEZWZhdWx0QVdTQWNjb3VudDtcbiAgcHJpdmF0ZSByZWFkb25seSBjcmVkZW50aWFsc0NhY2hlOiBDcmVkZW50aWFsc0NhY2hlO1xuICBwcml2YXRlIHJlYWRvbmx5IHByb2ZpbGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcmV0cnkgb3B0aW9ucyBmb3IgU0RLIGNsaWVudHNcbiAgICpcbiAgICogQmlnZ2VzdCBib3R0bGVuZWNrIGlzIENsb3VkRm9ybWF0aW9uLCB3aXRoIGEgMXRwcyBjYWxsIHJhdGUuIFdlIHdhbnQgdG8gYmVcbiAgICogYSBsaXR0bGUgbW9yZSB0ZW5hY2lvdXMgdGhhbiB0aGUgZGVmYXVsdHMsIGFuZCB3aXRoIGEgbGl0dGxlIG1vcmUgYnJlYXRoaW5nXG4gICAqIHJvb20gYmV0d2VlbiBjYWxscyAoZGVmYXVsdHMgYXJlIHtyZXRyaWVzPTMsIGJhc2U9MTAwfSkuXG4gICAqXG4gICAqIEkndmUgbGVmdCB0aGlzIHJ1bm5pbmcgaW4gYSB0aWdodCBsb29wIGZvciBhbiBob3VyIGFuZCB0aGUgdGhyb3R0bGUgZXJyb3JzXG4gICAqIGhhdmVuJ3QgZXNjYXBlZCB0aGUgcmV0cnkgbWVjaGFuaXNtLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSByZXRyeU9wdGlvbnMgPSB7IG1heFJldHJpZXM6IDYsIHJldHJ5RGVsYXlPcHRpb25zOiB7IGJhc2U6IDMwMCB9fTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTREtPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnByb2ZpbGUgPSBvcHRpb25zLnByb2ZpbGU7XG5cbiAgICBjb25zdCBkZWZhdWx0Q3JlZGVudGlhbFByb3ZpZGVyID0gbWFrZUNMSUNvbXBhdGlibGVDcmVkZW50aWFsUHJvdmlkZXIob3B0aW9ucy5wcm9maWxlLCBvcHRpb25zLmVjMmNyZWRzKTtcblxuICAgIC8vIEZpbmQgdGhlIHBhY2thZ2UuanNvbiBmcm9tIHRoZSBtYWluIHRvb2xraXRcbiAgICBjb25zdCBwa2cgPSAocmVxdWlyZS5tYWluIGFzIGFueSkucmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG4gICAgQVdTLmNvbmZpZy51cGRhdGUoe1xuICAgICAgICBjdXN0b21Vc2VyQWdlbnQ6IGAke3BrZy5uYW1lfS8ke3BrZy52ZXJzaW9ufWBcbiAgICB9KTtcblxuICAgIC8vIGh0dHBzOi8vYXdzLmFtYXpvbi5jb20vYmxvZ3MvZGV2ZWxvcGVyL3VzaW5nLXRoZS1hd3Mtc2RrLWZvci1qYXZhc2NyaXB0LWZyb20tYmVoaW5kLWEtcHJveHkvXG4gICAgaWYgKG9wdGlvbnMucHJveHlBZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMucHJveHlBZGRyZXNzID0gaHR0cHNQcm94eUZyb21FbnZpcm9ubWVudCgpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcm94eUFkZHJlc3MpIHsgLy8gSWdub3JlIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG4gICAgICBkZWJ1ZygnVXNpbmcgcHJveHkgc2VydmVyOiAlcycsIG9wdGlvbnMucHJveHlBZGRyZXNzKTtcbiAgICAgIEFXUy5jb25maWcudXBkYXRlKHtcbiAgICAgICAgaHR0cE9wdGlvbnM6IHsgYWdlbnQ6IHJlcXVpcmUoJ3Byb3h5LWFnZW50Jykob3B0aW9ucy5wcm94eUFkZHJlc3MpIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZGVmYXVsdEF3c0FjY291bnQgPSBuZXcgRGVmYXVsdEFXU0FjY291bnQoZGVmYXVsdENyZWRlbnRpYWxQcm92aWRlciwgZ2V0Q0xJQ29tcGF0aWJsZURlZmF1bHRSZWdpb24odGhpcy5wcm9maWxlKSk7XG4gICAgdGhpcy5jcmVkZW50aWFsc0NhY2hlID0gbmV3IENyZWRlbnRpYWxzQ2FjaGUodGhpcy5kZWZhdWx0QXdzQWNjb3VudCwgZGVmYXVsdENyZWRlbnRpYWxQcm92aWRlcik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xvdWRGb3JtYXRpb24oZW52aXJvbm1lbnQ6IEVudmlyb25tZW50LCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuQ2xvdWRGb3JtYXRpb24+IHtcbiAgICByZXR1cm4gbmV3IEFXUy5DbG91ZEZvcm1hdGlvbih7XG4gICAgICAuLi50aGlzLnJldHJ5T3B0aW9ucyxcbiAgICAgIHJlZ2lvbjogZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoZW52aXJvbm1lbnQuYWNjb3VudCwgbW9kZSlcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlYzIoYXdzQWNjb3VudElkOiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuRUMyPiB7XG4gICAgcmV0dXJuIG5ldyBBV1MuRUMyKHtcbiAgICAgIC4uLnRoaXMucmV0cnlPcHRpb25zLFxuICAgICAgcmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoYXdzQWNjb3VudElkLCBtb2RlKVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHNzbShhd3NBY2NvdW50SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5TU00+IHtcbiAgICByZXR1cm4gbmV3IEFXUy5TU00oe1xuICAgICAgLi4udGhpcy5yZXRyeU9wdGlvbnMsXG4gICAgICByZWdpb24sXG4gICAgICBjcmVkZW50aWFsczogYXdhaXQgdGhpcy5jcmVkZW50aWFsc0NhY2hlLmdldChhd3NBY2NvdW50SWQsIG1vZGUpXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgczMoZW52aXJvbm1lbnQ6IEVudmlyb25tZW50LCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuUzM+IHtcbiAgICByZXR1cm4gbmV3IEFXUy5TMyh7XG4gICAgICAuLi50aGlzLnJldHJ5T3B0aW9ucyxcbiAgICAgIHJlZ2lvbjogZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoZW52aXJvbm1lbnQuYWNjb3VudCwgbW9kZSlcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByb3V0ZTUzKGF3c0FjY291bnRJZDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlJvdXRlNTM+IHtcbiAgICByZXR1cm4gbmV3IEFXUy5Sb3V0ZTUzKHtcbiAgICAgIC4uLnRoaXMucmV0cnlPcHRpb25zLFxuICAgICAgcmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoYXdzQWNjb3VudElkLCBtb2RlKSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlY3IoZW52aXJvbm1lbnQ6IEVudmlyb25tZW50LCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuRUNSPiB7XG4gICAgcmV0dXJuIG5ldyBBV1MuRUNSKHtcbiAgICAgIC4uLnRoaXMucmV0cnlPcHRpb25zLFxuICAgICAgcmVnaW9uOiBlbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBjcmVkZW50aWFsczogYXdhaXQgdGhpcy5jcmVkZW50aWFsc0NhY2hlLmdldChlbnZpcm9ubWVudC5hY2NvdW50LCBtb2RlKVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlZmF1bHRSZWdpb24oKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gYXdhaXQgZ2V0Q0xJQ29tcGF0aWJsZURlZmF1bHRSZWdpb24odGhpcy5wcm9maWxlKTtcbiAgfVxuXG4gIHB1YmxpYyBkZWZhdWx0QWNjb3VudCgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRBd3NBY2NvdW50LmdldCgpO1xuICB9XG59XG5cbi8qKlxuICogQ2FjaGUgZm9yIGNyZWRlbnRpYWwgcHJvdmlkZXJzLlxuICpcbiAqIEdpdmVuIGFuIGFjY291bnQgYW5kIGFuIG9wZXJhdGluZyBtb2RlIChyZWFkIG9yIHdyaXRlKSB3aWxsIHJldHVybiBhblxuICogYXBwcm9wcmlhdGUgY3JlZGVudGlhbCBwcm92aWRlciBmb3IgY3JlZGVudGlhbHMgZm9yIHRoZSBnaXZlbiBhY2NvdW50LiBUaGVcbiAqIGNyZWRlbnRpYWwgcHJvdmlkZXIgd2lsbCBiZSBjYWNoZWQgc28gdGhhdCBtdWx0aXBsZSBBV1MgY2xpZW50cyBmb3IgdGhlIHNhbWVcbiAqIGVudmlyb25tZW50IHdpbGwgbm90IG1ha2UgbXVsdGlwbGUgbmV0d29yayBjYWxscyB0byBvYnRhaW4gY3JlZGVudGlhbHMuXG4gKlxuICogV2lsbCB1c2UgZGVmYXVsdCBjcmVkZW50aWFscyBpZiB0aGV5IGFyZSBmb3IgdGhlIHJpZ2h0IGFjY291bnQ7IG90aGVyd2lzZSxcbiAqIGFsbCBsb2FkZWQgY3JlZGVudGlhbCBwcm92aWRlciBwbHVnaW5zIHdpbGwgYmUgdHJpZWQgdG8gb2J0YWluIGNyZWRlbnRpYWxzXG4gKiBmb3IgdGhlIGdpdmVuIGFjY291bnQuXG4gKi9cbmNsYXNzIENyZWRlbnRpYWxzQ2FjaGUge1xuICBwcml2YXRlIHJlYWRvbmx5IGNhY2hlOiB7W2tleTogc3RyaW5nXTogQVdTLkNyZWRlbnRpYWxzfSA9IHt9O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRBd3NBY2NvdW50OiBEZWZhdWx0QVdTQWNjb3VudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRDcmVkZW50aWFsUHJvdmlkZXI6IFByb21pc2U8QVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluPikge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldChhd3NBY2NvdW50SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLkNyZWRlbnRpYWxzPiB7XG4gICAgY29uc3Qga2V5ID0gYCR7YXdzQWNjb3VudElkfS0ke21vZGV9YDtcbiAgICBpZiAoIShrZXkgaW4gdGhpcy5jYWNoZSkpIHtcbiAgICAgIHRoaXMuY2FjaGVba2V5XSA9IGF3YWl0IHRoaXMuZ2V0Q3JlZGVudGlhbHMoYXdzQWNjb3VudElkLCBtb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVba2V5XTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0Q3JlZGVudGlhbHMoYXdzQWNjb3VudElkOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5DcmVkZW50aWFscz4ge1xuICAgIC8vIElmIHJlcXVlc3RlZCBhY2NvdW50IGlzIHVuZGVmaW5lZCBvciBlcXVhbCB0byBkZWZhdWx0IGFjY291bnQsIHVzZSBkZWZhdWx0IGNyZWRlbnRpYWxzIHByb3ZpZGVyLlxuICAgIC8vIChOb3RlIHRoYXQgd2UgaWdub3JlIHRoZSBtb2RlIGluIHRoaXMgY2FzZSwgaWYgeW91IHByZWxvYWRlZCBjcmVkZW50aWFscyB0aGV5IGJldHRlciBiZSBjb3JyZWN0ISlcbiAgICBjb25zdCBkZWZhdWx0QWNjb3VudCA9IGF3YWl0IHRoaXMuZGVmYXVsdEF3c0FjY291bnQuZ2V0KCk7XG4gICAgaWYgKCFhd3NBY2NvdW50SWQgfHwgYXdzQWNjb3VudElkID09PSBkZWZhdWx0QWNjb3VudCkge1xuICAgICAgZGVidWcoYFVzaW5nIGRlZmF1bHQgQVdTIFNESyBjcmVkZW50aWFscyBmb3IgYWNjb3VudCAke2F3c0FjY291bnRJZH1gKTtcblxuICAgICAgLy8gQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4gZXh0ZW5kcyBDcmVkZW50aWFscywgYnV0IHRoYXQgaXMgYSBsaWUuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1zZGstanMvaXNzdWVzLzIyMzVcbiAgICAgIC8vIENhbGwgcmVzb2x2ZSgpIGluc3RlYWQuXG4gICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZGVmYXVsdENyZWRlbnRpYWxQcm92aWRlcikucmVzb2x2ZVByb21pc2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmllZFNvdXJjZXM6IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZVtdID0gW107XG4gICAgLy8gT3RoZXJ3aXNlLCBpbnNwZWN0IHRoZSB2YXJpb3VzIGNyZWRlbnRpYWwgc291cmNlcyB3ZSBoYXZlXG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2YgUGx1Z2luSG9zdC5pbnN0YW5jZS5jcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VzKSB7XG4gICAgICBpZiAoIShhd2FpdCBzb3VyY2UuaXNBdmFpbGFibGUoKSkpIHtcbiAgICAgICAgZGVidWcoJ0NyZWRlbnRpYWxzIHNvdXJjZSAlcyBpcyBub3QgYXZhaWxhYmxlLCBpZ25vcmluZyBpdC4nLCBzb3VyY2UubmFtZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdHJpZWRTb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICAgIGlmICghKGF3YWl0IHNvdXJjZS5jYW5Qcm92aWRlQ3JlZGVudGlhbHMoYXdzQWNjb3VudElkKSkpIHsgY29udGludWU7IH1cbiAgICAgIGRlYnVnKGBVc2luZyAke3NvdXJjZS5uYW1lfSBjcmVkZW50aWFscyBmb3IgYWNjb3VudCAke2F3c0FjY291bnRJZH1gKTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyT3JDcmVkcyA9IGF3YWl0IHNvdXJjZS5nZXRQcm92aWRlcihhd3NBY2NvdW50SWQsIG1vZGUpO1xuXG4gICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaWYgdGhlIHBsdWdpbiByZXR1cm5zIGEgUHJvdmlkZXJDaGFpbiwgcmVzb2x2ZSB0aGF0IGNoYWluLlxuICAgICAgLy8gT3RoZXJ3aXNlIGl0IG11c3QgaGF2ZSByZXR1cm5lZCBjcmVkZW50aWFscy5cbiAgICAgIGlmICgocHJvdmlkZXJPckNyZWRzIGFzIGFueSkucmVzb2x2ZVByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IChwcm92aWRlck9yQ3JlZHMgYXMgYW55KS5yZXNvbHZlUHJvbWlzZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3ZpZGVyT3JDcmVkcztcbiAgICB9XG4gICAgY29uc3Qgc291cmNlTmFtZXMgPSBbJ2RlZmF1bHQgY3JlZGVudGlhbHMnXS5jb25jYXQodHJpZWRTb3VyY2VzLm1hcChzID0+IHMubmFtZSkpLmpvaW4oJywgJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOZWVkIHRvIHBlcmZvcm0gQVdTIGNhbGxzIGZvciBhY2NvdW50ICR7YXdzQWNjb3VudElkfSwgYnV0IG5vIGNyZWRlbnRpYWxzIGZvdW5kLiBUcmllZDogJHtzb3VyY2VOYW1lc30uYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyB0byByZXRyaWV2ZSB0aGUgYWNjb3VudCBmb3IgZGVmYXVsdCBjcmVkZW50aWFscyBhbmQgY2FjaGUgaXQuXG4gKlxuICogVXNlcyB0aGUgZGVmYXVsdCBjcmVkZW50aWFscyBwcm92aWRlciB0byBvYnRhaW4gY3JlZGVudGlhbHMgKGlmIGF2YWlsYWJsZSksXG4gKiBhbmQgdXNlcyB0aG9zZSBjcmVkZW50aWFscyB0byBjYWxsIFNUUyB0byByZXF1ZXN0IHRoZSBjdXJyZW50IGFjY291bnQgSUQuXG4gKlxuICogVGhlIGNyZWRlbnRpYWxzID0+IGFjY291bnRJZCBsb29rdXAgaXMgY2FjaGVkIG9uIGRpc2ssIHNpbmNlIGl0J3NcbiAqIGd1YXJhbnRlZWQgdGhhdCBpZ3ZlbiBhY2Nlc3Mga2V5IHdpbGwgYWx3YXlzIHJlbWFpbiBmb3IgdGhlIHNhbWUgYWNjb3VudC5cbiAqL1xuY2xhc3MgRGVmYXVsdEFXU0FjY291bnQge1xuICBwcml2YXRlIGRlZmF1bHRBY2NvdW50RmV0Y2hlZCA9IGZhbHNlO1xuICBwcml2YXRlIGRlZmF1bHRBY2NvdW50SWQ/OiBzdHJpbmcgPSB1bmRlZmluZWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgYWNjb3VudENhY2hlID0gbmV3IEFjY291bnRBY2Nlc3NLZXlDYWNoZSgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSByZWFkb25seSBkZWZhdWx0Q3JlZGVudGlhbHNQcm92aWRlcjogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4+LFxuICAgICAgcHJpdmF0ZSByZWFkb25seSByZWdpb246IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPikge1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGVmYXVsdCBhY2NvdW50XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0KCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKCF0aGlzLmRlZmF1bHRBY2NvdW50RmV0Y2hlZCkge1xuICAgICAgdGhpcy5kZWZhdWx0QWNjb3VudElkID0gYXdhaXQgdGhpcy5sb29rdXBEZWZhdWx0QWNjb3VudCgpO1xuICAgICAgdGhpcy5kZWZhdWx0QWNjb3VudEZldGNoZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0QWNjb3VudElkO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb29rdXBEZWZhdWx0QWNjb3VudCgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGVyZSBqdXN0IGlzICpOTyogd2F5IHRvIGRvIEFzc3VtZVJvbGUgY3JlZGVudGlhbHMgYXMgbG9uZyBhcyBBV1NfU0RLX0xPQURfQ09ORklHIGlzIG5vdCBzZXQuIFRoZSBTREtcbiAgICAgIC8vIGNyYXNoIGlmIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0IHRob3VnaC4gU28gc2V0IHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpZiB3ZSBjYW4gZmluZCB0aGF0IGZpbGUuXG4gICAgICBhd2FpdCBzZXRDb25maWdWYXJpYWJsZSgpO1xuXG4gICAgICBkZWJ1ZygnUmVzb2x2aW5nIGRlZmF1bHQgY3JlZGVudGlhbHMnKTtcbiAgICAgIGNvbnN0IGNyZWRlbnRpYWxQcm92aWRlciA9IGF3YWl0IHRoaXMuZGVmYXVsdENyZWRlbnRpYWxzUHJvdmlkZXI7XG4gICAgICBjb25zdCBjcmVkcyA9IGF3YWl0IGNyZWRlbnRpYWxQcm92aWRlci5yZXNvbHZlUHJvbWlzZSgpO1xuXG4gICAgICBjb25zdCBhY2Nlc3NLZXlJZCA9IGNyZWRzLmFjY2Vzc0tleUlkO1xuICAgICAgaWYgKCFhY2Nlc3NLZXlJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZXNvbHZlIEFXUyBjcmVkZW50aWFscyAoc2V0dXAgd2l0aCBcImF3cyBjb25maWd1cmVcIiknKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWNjb3VudElkID0gYXdhaXQgdGhpcy5hY2NvdW50Q2FjaGUuZmV0Y2goY3JlZHMuYWNjZXNzS2V5SWQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBvbmUsIHJlc29sdmUgZnJvbSBTVFMgYW5kIHN0b3JlIGluIGNhY2hlLlxuICAgICAgICBkZWJ1ZygnTG9va2luZyB1cCBkZWZhdWx0IGFjY291bnQgSUQgZnJvbSBTVFMnKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV3IEFXUy5TVFMoeyBjcmVkZW50aWFsczogY3JlZHMsIHJlZ2lvbjogYXdhaXQgdGhpcy5yZWdpb24gfSkuZ2V0Q2FsbGVySWRlbnRpdHkoKS5wcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IGFpZCA9IHJlc3VsdC5BY2NvdW50O1xuICAgICAgICBpZiAoIWFpZCkge1xuICAgICAgICAgIGRlYnVnKCdTVFMgZGlkblxcJ3QgcmV0dXJuIGFuIGFjY291bnQgSUQnKTtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdEZWZhdWx0IGFjY291bnQgSUQ6JywgYWlkKTtcbiAgICAgICAgcmV0dXJuIGFpZDtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYWNjb3VudElkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCdVbmFibGUgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IEFXUyBhY2NvdW50IChkaWQgeW91IGNvbmZpZ3VyZSBcImF3cyBjb25maWd1cmVcIj8pOicsIGUpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBCdWlsZCBhbiBBV1MgQ0xJLWNvbXBhdGlibGUgY3JlZGVudGlhbCBjaGFpbiBwcm92aWRlclxuICpcbiAqIFRoaXMgaXMgc2ltaWxhciB0byB0aGUgZGVmYXVsdCBjcmVkZW50aWFsIHByb3ZpZGVyIGNoYWluIGNyZWF0ZWQgYnkgdGhlIFNES1xuICogZXhjZXB0IGl0IGFsc28gYWNjZXB0cyB0aGUgcHJvZmlsZSBhcmd1bWVudCBpbiB0aGUgY29uc3RydWN0b3IgKG5vdCBqdXN0IGZyb21cbiAqIHRoZSBlbnZpcm9ubWVudCkuXG4gKlxuICogVG8gbWltaWMgdGhlIEFXUyBDTEkgYmVoYXZpb3I6XG4gKlxuICogLSB3ZSBkZWZhdWx0IHRvIH4vLmF3cy9jcmVkZW50aWFscyBpZiBlbnZpcm9ubWVudCB2YXJpYWJsZSBmb3IgY3JlZGVudGlhbHNcbiAqIGZpbGUgbG9jYXRpb24gaXMgbm90IGdpdmVuIChTREsgZXhwZWN0cyBleHBsaWNpdCBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aXRoIG5hbWUpLlxuICogLSBBV1NfREVGQVVMVF9QUk9GSUxFIGlzIGFsc28gaW5zcGVjdGVkIGZvciBwcm9maWxlIG5hbWUgKG5vdCBqdXN0IEFXU19QUk9GSUxFKS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWFrZUNMSUNvbXBhdGlibGVDcmVkZW50aWFsUHJvdmlkZXIocHJvZmlsZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBlYzJjcmVkczogYm9vbGVhbiB8IHVuZGVmaW5lZCkge1xuICBwcm9maWxlID0gcHJvZmlsZSB8fCBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9QUk9GSUxFIHx8ICdkZWZhdWx0JztcblxuICAvLyBOZWVkIHRvIGNvbnN0cnVjdCBmaWxlbmFtZSBvdXJzZWx2ZXMsIHdpdGhvdXQgYXBwcm9wcmlhdGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gIC8vIG5vIGRlZmF1bHRzIHVzZWQgYnkgSlMgU0RLLlxuICBjb25zdCBmaWxlbmFtZSA9IHByb2Nlc3MuZW52LkFXU19TSEFSRURfQ1JFREVOVElBTFNfRklMRSB8fCBwYXRoLmpvaW4ob3MuaG9tZWRpcigpLCAnLmF3cycsICdjcmVkZW50aWFscycpO1xuXG4gIGNvbnN0IHNvdXJjZXMgPSBbXG4gICAgKCkgPT4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBV1MnKSxcbiAgICAoKSA9PiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FNQVpPTicpLFxuICBdO1xuICBpZiAoZnMucGF0aEV4aXN0cyhmaWxlbmFtZSkpIHtcbiAgICBzb3VyY2VzLnB1c2goKCkgPT4gbmV3IEFXUy5TaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMoeyBwcm9maWxlLCBmaWxlbmFtZSB9KSk7XG4gIH1cblxuICBpZiAoaGFzRWNzQ3JlZGVudGlhbHMoKSkge1xuICAgIHNvdXJjZXMucHVzaCgoKSA9PiBuZXcgQVdTLkVDU0NyZWRlbnRpYWxzKCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGVsc2UgaWY6IGRvbid0IGdldCBFQzIgY3JlZHMgaWYgd2Ugc2hvdWxkIGhhdmUgZ290dGVuIEVDUyBjcmVkcy0tRUNTIGluc3RhbmNlcyBhbHNvXG4gICAgLy8gcnVuIG9uIEVDMiBib3hlcyBidXQgdGhlIGNyZWRzIHJlcHJlc2VudCBzb21ldGhpbmcgZGlmZmVyZW50LiBTYW1lIGJlaGF2aW9yIGFzXG4gICAgLy8gdXBzdHJlYW0gY29kZS5cblxuICAgIGlmIChlYzJjcmVkcyA9PT0gdW5kZWZpbmVkKSB7IGVjMmNyZWRzID0gYXdhaXQgaGFzRWMyQ3JlZGVudGlhbHMoKTsgfVxuXG4gICAgaWYgKGVjMmNyZWRzKSB7XG4gICAgICBzb3VyY2VzLnB1c2goKCkgPT4gbmV3IEFXUy5FQzJNZXRhZGF0YUNyZWRlbnRpYWxzKCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKHNvdXJjZXMpO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZGVmYXVsdCByZWdpb24gaW4gYSBDTEktY29tcGF0aWJsZSB3YXlcbiAqXG4gKiBNb3N0bHkgY29waWVkIGZyb20gbm9kZV9sb2FkZXIuanMsIGJ1dCB3aXRoIHRoZSBmb2xsb3dpbmcgZGlmZmVyZW5jZXM6XG4gKlxuICogLSBUYWtlcyBhIHJ1bnRpbWUgcHJvZmlsZSBuYW1lIHRvIGxvYWQgdGhlIHJlZ2lvbiBmcm9tLCBub3QganVzdCBiYXNlZCBvbiBlbnZpcm9ubWVudFxuICogICB2YXJpYWJsZXMgYXQgcHJvY2VzcyBzdGFydC5cbiAqIC0gV2UgaGF2ZSBuZWVkZWQgdG8gY3JlYXRlIGEgbG9jYWwgY29weSBvZiB0aGUgU2hhcmVkSW5pRmlsZSBjbGFzcyBiZWNhdXNlIHRoZVxuICogICBpbXBsZW1lbnRhdGlvbiBpbiAnYXdzLXNkaycgaXMgcHJpdmF0ZSAoYW5kIHRoZSBkZWZhdWx0IHVzZSBvZiBpdCBpbiB0aGVcbiAqICAgU0RLIGRvZXMgbm90IGFsbG93IHVzIHRvIHNwZWNpZnkgYSBwcm9maWxlIGF0IHJ1bnRpbWUpLlxuICogLSBBV1NfREVGQVVMVF9QUk9GSUxFIGFuZCBBV1NfREVGQVVMVF9SRUdJT04gYXJlIGFsc28gdXNlZCBhcyBlbnZpcm9ubWVudFxuICogICB2YXJpYWJsZXMgdG8gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJlZ2lvbi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0Q0xJQ29tcGF0aWJsZURlZmF1bHRSZWdpb24ocHJvZmlsZTogc3RyaW5nIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgcHJvZmlsZSA9IHByb2ZpbGUgfHwgcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUFJPRklMRSB8fCAnZGVmYXVsdCc7XG5cbiAgLy8gRGVmYXVsdHMgaW5zaWRlIGNvbnN0cnVjdG9yXG4gIGNvbnN0IHRvQ2hlY2sgPSBbXG4gICAge2ZpbGVuYW1lOiBwcm9jZXNzLmVudi5BV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUgfSxcbiAgICB7aXNDb25maWc6IHRydWUsIGZpbGVuYW1lOiBwcm9jZXNzLmVudi5BV1NfQ09ORklHX0ZJTEV9LFxuICBdO1xuXG4gIGxldCByZWdpb24gPSBwcm9jZXNzLmVudi5BV1NfUkVHSU9OIHx8IHByb2Nlc3MuZW52LkFNQVpPTl9SRUdJT04gfHxcbiAgICBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9SRUdJT04gfHwgcHJvY2Vzcy5lbnYuQU1BWk9OX0RFRkFVTFRfUkVHSU9OO1xuXG4gIHdoaWxlICghcmVnaW9uICYmIHRvQ2hlY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGNvbmZpZ0ZpbGUgPSBuZXcgU2hhcmVkSW5pRmlsZSh0b0NoZWNrLnNoaWZ0KCkpO1xuICAgIGNvbnN0IHNlY3Rpb24gPSBhd2FpdCBjb25maWdGaWxlLmdldFByb2ZpbGUocHJvZmlsZSk7XG4gICAgcmVnaW9uID0gc2VjdGlvbiAmJiBzZWN0aW9uLnJlZ2lvbjtcbiAgfVxuXG4gIHJldHVybiByZWdpb247XG59XG5cbi8qKlxuICogRmluZCBhbmQgcmV0dXJuIHRoZSBjb25maWd1cmVkIEhUVFBTIHByb3h5IGFkZHJlc3NcbiAqL1xuZnVuY3Rpb24gaHR0cHNQcm94eUZyb21FbnZpcm9ubWVudCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAocHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHk7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52LkhUVFBTX1BST1hZKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkhUVFBTX1BST1hZO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgaXQgbG9va3MgbGlrZSB3ZSdsbCBoYXZlIEVDUyBjcmVkZW50aWFscyBhdmFpbGFibGVcbiAqL1xuZnVuY3Rpb24gaGFzRWNzQ3JlZGVudGlhbHMoKSB7XG4gIHJldHVybiAoQVdTLkVDU0NyZWRlbnRpYWxzLnByb3RvdHlwZSBhcyBhbnkpLmlzQ29uZmlndXJlZEZvckVjc0NyZWRlbnRpYWxzKCk7XG59XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgd2UncmUgb24gYW4gRUMyIGluc3RhbmNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhc0VjMkNyZWRlbnRpYWxzKCkge1xuICBkZWJ1ZyhcIkRldGVybWluaW5nIHdoZXRoZXIgd2UncmUgb24gYW4gRUMyIGluc3RhbmNlLlwiKTtcblxuICBsZXQgaW5zdGFuY2UgPSBmYWxzZTtcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTRUMyL2xhdGVzdC9XaW5kb3dzR3VpZGUvaWRlbnRpZnlfZWMyX2luc3RhbmNlcy5odG1sXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXRpbC5wcm9taXNpZnkoY2hpbGRfcHJvY2Vzcy5leGVjKSgnd21pYyBwYXRoIHdpbjMyX2NvbXB1dGVyc3lzdGVtcHJvZHVjdCBnZXQgdXVpZCcsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gICAgLy8gb3V0cHV0IGxvb2tzIGxpa2VcbiAgICAvLyAgVVVJRFxuICAgIC8vICBFQzJBRTE0NS1EMURDLTEzQjItOTRFRC0wMTIzNEFCQ0RFRlxuICAgIGNvbnN0IGxpbmVzID0gcmVzdWx0LnN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICBpbnN0YW5jZSA9IGxpbmVzLnNvbWUoeCA9PiBtYXRjaGVzUmVnZXgoL15lYzIvaSwgeCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NFQzIvbGF0ZXN0L1VzZXJHdWlkZS9pZGVudGlmeV9lYzJfaW5zdGFuY2VzLmh0bWxcbiAgICBjb25zdCBmaWxlczogQXJyYXk8W3N0cmluZywgUmVnRXhwXT4gPSBbXG4gICAgICAvLyBUaGlzIHJlY29nbml6ZXMgdGhlIFhlbiBoeXBlcnZpc29yIGJhc2VkIGluc3RhbmNlcyAocHJlLTV0aCBnZW4pXG4gICAgICBbJy9zeXMvaHlwZXJ2aXNvci91dWlkJywgL15lYzIvaV0sXG5cbiAgICAgIC8vIFRoaXMgcmVjb2duaXplcyB0aGUgbmV3IEh5cGVydmlzb3IgKDV0aC1nZW4gaW5zdGFuY2VzIGFuZCBoaWdoZXIpXG4gICAgICAvLyBDYW4ndCB1c2UgdGhlIGFkdmVydGlzZWQgZmlsZSAnL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL3Byb2R1Y3RfdXVpZCcgYmVjYXVzZSBpdCByZXF1aXJlcyByb290IHRvIHJlYWQuXG4gICAgICAvLyBJbnN0ZWFkLCBzeXNfdmVuZG9yIGNvbnRhaW5zIHNvbWV0aGluZyBsaWtlICdBbWF6b24gRUMyJy5cbiAgICAgIFsnL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL3N5c192ZW5kb3InLCAvZWMyL2ldLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBbZmlsZSwgcmVdIG9mIGZpbGVzKSB7XG4gICAgICBpZiAobWF0Y2hlc1JlZ2V4KHJlLCBhd2FpdCByZWFkSWZQb3NzaWJsZShmaWxlKSkpIHtcbiAgICAgICAgaW5zdGFuY2UgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWJ1ZyhpbnN0YW5jZSA/ICdMb29rcyBsaWtlIEVDMiBpbnN0YW5jZS4nIDogJ0RvZXMgbm90IGxvb2sgbGlrZSBFQzIgaW5zdGFuY2UuJyk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2V0Q29uZmlnVmFyaWFibGUoKSB7XG4gIGNvbnN0IGhvbWVEaXIgPSBwcm9jZXNzLmVudi5IT01FIHx8IHByb2Nlc3MuZW52LlVTRVJQUk9GSUxFXG4gICAgfHwgKHByb2Nlc3MuZW52LkhPTUVQQVRIID8gKChwcm9jZXNzLmVudi5IT01FRFJJVkUgfHwgJ0M6LycpICsgcHJvY2Vzcy5lbnYuSE9NRVBBVEgpIDogbnVsbCkgfHwgb3MuaG9tZWRpcigpO1xuXG4gIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKHBhdGgucmVzb2x2ZShob21lRGlyLCAnLmF3cycsICdjb25maWcnKSkpIHtcbiAgICBwcm9jZXNzLmVudi5BV1NfU0RLX0xPQURfQ09ORklHID0gJzEnO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRJZlBvc3NpYmxlKGZpbGVuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICB0cnkge1xuICAgIGlmICghYXdhaXQgZnMucGF0aEV4aXN0cyhmaWxlbmFtZSkpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIHJldHVybiBmcy5yZWFkRmlsZShmaWxlbmFtZSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKGUpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hlc1JlZ2V4KHJlOiBSZWdFeHAsIHM6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICByZXR1cm4gcyAhPT0gdW5kZWZpbmVkICYmIHJlLmV4ZWMocykgIT09IG51bGw7XG59XG4iXX0=