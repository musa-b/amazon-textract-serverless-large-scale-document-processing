"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logging_1 = require("../logging");
const serialize_1 = require("../serialize");
const credentials_1 = require("./aws-auth/credentials");
const deploy_stack_1 = require("./deploy-stack");
const toolkit_info_1 = require("./toolkit-info");
exports.DEFAULT_TOOLKIT_STACK_NAME = 'CDKToolkit';
/**
 * Default provisioner (applies to CloudFormation).
 */
class CloudFormationDeploymentTarget {
    constructor(props) {
        this.aws = props.aws;
    }
    async readCurrentTemplate(stack) {
        logging_1.debug(`Reading existing template for stack ${stack.name}.`);
        const cfn = await this.aws.cloudFormation(stack.environment, credentials_1.Mode.ForReading);
        try {
            const response = await cfn.getTemplate({ StackName: stack.name }).promise();
            return (response.TemplateBody && serialize_1.deserializeStructure(response.TemplateBody)) || {};
        }
        catch (e) {
            if (e.code === 'ValidationError' && e.message === `Stack with id ${stack.name} does not exist`) {
                return {};
            }
            else {
                throw e;
            }
        }
    }
    async deployStack(options) {
        const toolkitInfo = await toolkit_info_1.loadToolkitInfo(options.stack.environment, this.aws, options.toolkitStackName || exports.DEFAULT_TOOLKIT_STACK_NAME);
        return deploy_stack_1.deployStack({
            stack: options.stack,
            deployName: options.deployName,
            roleArn: options.roleArn,
            quiet: options.quiet,
            sdk: this.aws,
            ci: options.ci,
            reuseAssets: options.reuseAssets,
            toolkitInfo,
        });
    }
}
exports.CloudFormationDeploymentTarget = CloudFormationDeploymentTarget;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwbG95bWVudC10YXJnZXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkZXBsb3ltZW50LXRhcmdldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLHdDQUFtQztBQUNuQyw0Q0FBb0Q7QUFDcEQsd0RBQThDO0FBQzlDLGlEQUFnRTtBQUNoRSxpREFBaUQ7QUFHcEMsUUFBQSwwQkFBMEIsR0FBRyxZQUFZLENBQUM7QUE0QnZEOztHQUVHO0FBQ0gsTUFBYSw4QkFBOEI7SUFHekMsWUFBWSxLQUF1QjtRQUNqQyxJQUFJLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDdkIsQ0FBQztJQUVNLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxLQUE2QjtRQUM1RCxlQUFLLENBQUMsdUNBQXVDLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBRTVELE1BQU0sR0FBRyxHQUFHLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxrQkFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzlFLElBQUk7WUFDRixNQUFNLFFBQVEsR0FBRyxNQUFNLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDNUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxZQUFZLElBQUksZ0NBQW9CLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ3JGO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssaUJBQWlCLElBQUksQ0FBQyxDQUFDLE9BQU8sS0FBSyxpQkFBaUIsS0FBSyxDQUFDLElBQUksaUJBQWlCLEVBQUU7Z0JBQzlGLE9BQU8sRUFBRSxDQUFDO2FBQ1g7aUJBQU07Z0JBQ0wsTUFBTSxDQUFDLENBQUM7YUFDVDtTQUNGO0lBQ0gsQ0FBQztJQUVNLEtBQUssQ0FBQyxXQUFXLENBQUMsT0FBMkI7UUFDbEQsTUFBTSxXQUFXLEdBQUcsTUFBTSw4QkFBZSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLGdCQUFnQixJQUFJLGtDQUEwQixDQUFDLENBQUM7UUFDdkksT0FBTywwQkFBVyxDQUFDO1lBQ2pCLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSztZQUNwQixVQUFVLEVBQUUsT0FBTyxDQUFDLFVBQVU7WUFDOUIsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPO1lBQ3hCLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSztZQUNwQixHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUc7WUFDYixFQUFFLEVBQUUsT0FBTyxDQUFDLEVBQUU7WUFDZCxXQUFXLEVBQUUsT0FBTyxDQUFDLFdBQVc7WUFDaEMsV0FBVztTQUNaLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQXBDRCx3RUFvQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3hhcGkgPSByZXF1aXJlKCdAYXdzLWNkay9jeC1hcGknKTtcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBkZXNlcmlhbGl6ZVN0cnVjdHVyZSB9IGZyb20gJy4uL3NlcmlhbGl6ZSc7XG5pbXBvcnQgeyBNb2RlIH0gZnJvbSAnLi9hd3MtYXV0aC9jcmVkZW50aWFscyc7XG5pbXBvcnQgeyBkZXBsb3lTdGFjaywgRGVwbG95U3RhY2tSZXN1bHQgfSBmcm9tICcuL2RlcGxveS1zdGFjayc7XG5pbXBvcnQgeyBsb2FkVG9vbGtpdEluZm8gfSBmcm9tICcuL3Rvb2xraXQtaW5mbyc7XG5pbXBvcnQgeyBTREsgfSBmcm9tICcuL3V0aWwvc2RrJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FID0gJ0NES1Rvb2xraXQnO1xuXG5leHBvcnQgdHlwZSBUZW1wbGF0ZSA9IHsgW2tleTogc3RyaW5nXTogYW55IH07XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBwcm92aXNpb25lcnNcbiAqXG4gKiBQcm92aXNpb25lcnMgYXBwbHkgdGVtcGxhdGVzIHRvIHRoZSBjbG91ZCBpbmZyYXN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJRGVwbG95bWVudFRhcmdldCB7XG4gIHJlYWRDdXJyZW50VGVtcGxhdGUoc3RhY2s6IGN4YXBpLlN5bnRoZXNpemVkU3RhY2spOiBQcm9taXNlPFRlbXBsYXRlPjtcbiAgZGVwbG95U3RhY2sob3B0aW9uczogRGVwbG95U3RhY2tPcHRpb25zKTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVwbG95U3RhY2tPcHRpb25zIHtcbiAgc3RhY2s6IGN4YXBpLlN5bnRoZXNpemVkU3RhY2s7XG4gIHJvbGVBcm4/OiBzdHJpbmc7XG4gIGRlcGxveU5hbWU/OiBzdHJpbmc7XG4gIHF1aWV0PzogYm9vbGVhbjtcbiAgY2k/OiBib29sZWFuO1xuICB0b29sa2l0U3RhY2tOYW1lPzogc3RyaW5nO1xuICByZXVzZUFzc2V0cz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb3Zpc2lvbmVyUHJvcHMge1xuICBhd3M6IFNESztcbn1cblxuLyoqXG4gKiBEZWZhdWx0IHByb3Zpc2lvbmVyIChhcHBsaWVzIHRvIENsb3VkRm9ybWF0aW9uKS5cbiAqL1xuZXhwb3J0IGNsYXNzIENsb3VkRm9ybWF0aW9uRGVwbG95bWVudFRhcmdldCBpbXBsZW1lbnRzIElEZXBsb3ltZW50VGFyZ2V0IHtcbiAgcHJpdmF0ZSByZWFkb25seSBhd3M6IFNESztcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvdmlzaW9uZXJQcm9wcykge1xuICAgIHRoaXMuYXdzID0gcHJvcHMuYXdzO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlYWRDdXJyZW50VGVtcGxhdGUoc3RhY2s6IGN4YXBpLlN5bnRoZXNpemVkU3RhY2spOiBQcm9taXNlPFRlbXBsYXRlPiB7XG4gICAgZGVidWcoYFJlYWRpbmcgZXhpc3RpbmcgdGVtcGxhdGUgZm9yIHN0YWNrICR7c3RhY2submFtZX0uYCk7XG5cbiAgICBjb25zdCBjZm4gPSBhd2FpdCB0aGlzLmF3cy5jbG91ZEZvcm1hdGlvbihzdGFjay5lbnZpcm9ubWVudCwgTW9kZS5Gb3JSZWFkaW5nKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjZm4uZ2V0VGVtcGxhdGUoeyBTdGFja05hbWU6IHN0YWNrLm5hbWUgfSkucHJvbWlzZSgpO1xuICAgICAgcmV0dXJuIChyZXNwb25zZS5UZW1wbGF0ZUJvZHkgJiYgZGVzZXJpYWxpemVTdHJ1Y3R1cmUocmVzcG9uc2UuVGVtcGxhdGVCb2R5KSkgfHwge307XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSA9PT0gJ1ZhbGlkYXRpb25FcnJvcicgJiYgZS5tZXNzYWdlID09PSBgU3RhY2sgd2l0aCBpZCAke3N0YWNrLm5hbWV9IGRvZXMgbm90IGV4aXN0YCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZXBsb3lTdGFjayhvcHRpb25zOiBEZXBsb3lTdGFja09wdGlvbnMpOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0PiB7XG4gICAgY29uc3QgdG9vbGtpdEluZm8gPSBhd2FpdCBsb2FkVG9vbGtpdEluZm8ob3B0aW9ucy5zdGFjay5lbnZpcm9ubWVudCwgdGhpcy5hd3MsIG9wdGlvbnMudG9vbGtpdFN0YWNrTmFtZSB8fCBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRSk7XG4gICAgcmV0dXJuIGRlcGxveVN0YWNrKHtcbiAgICAgIHN0YWNrOiBvcHRpb25zLnN0YWNrLFxuICAgICAgZGVwbG95TmFtZTogb3B0aW9ucy5kZXBsb3lOYW1lLFxuICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgcXVpZXQ6IG9wdGlvbnMucXVpZXQsXG4gICAgICBzZGs6IHRoaXMuYXdzLFxuICAgICAgY2k6IG9wdGlvbnMuY2ksXG4gICAgICByZXVzZUFzc2V0czogb3B0aW9ucy5yZXVzZUFzc2V0cyxcbiAgICAgIHRvb2xraXRJbmZvLFxuICAgIH0pO1xuICB9XG59Il19