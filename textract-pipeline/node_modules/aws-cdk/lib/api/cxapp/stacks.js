"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const regionInfo = require("@aws-cdk/region-info");
const colors = require("colors/safe");
const minimatch = require("minimatch");
const contextproviders = require("../../context-providers");
const logging_1 = require("../../logging");
const renames_1 = require("../../renames");
const cdkUtil = require("../../util");
const toposort_1 = require("../util/toposort");
/**
 * Routines to get stacks from an app
 *
 * In a class because it shares some global state
 */
class AppStacks {
    constructor(props) {
        this.props = props;
        this.renames = props.renames || new renames_1.Renames({});
    }
    /**
     * List all stacks in the CX and return the selected ones
     *
     * It's an error if there are no stacks to select, or if one of the requested parameters
     * refers to a nonexistant stack.
     */
    async selectStacks(selectors, extendedSelection) {
        selectors = selectors.filter(s => s != null); // filter null/undefined
        const stacks = await this.listStacks();
        if (stacks.length === 0) {
            throw new Error('This app contains no stacks');
        }
        if (selectors.length === 0) {
            // remove non-auto deployed Stacks
            const autoDeployedStacks = stacks.filter(s => s.autoDeploy !== false);
            logging_1.debug('Stack name not specified, so defaulting to all available stacks: ' + listStackNames(autoDeployedStacks));
            return this.applyRenames(autoDeployedStacks);
        }
        const allStacks = new Map();
        for (const stack of stacks) {
            allStacks.set(stack.name, stack);
        }
        // For every selector argument, pick stacks from the list.
        const selectedStacks = new Map();
        for (const pattern of selectors) {
            let found = false;
            for (const stack of stacks) {
                if (minimatch(stack.name, pattern) && !selectedStacks.has(stack.name)) {
                    selectedStacks.set(stack.name, stack);
                    found = true;
                }
            }
            if (!found) {
                throw new Error(`No stack found matching '${pattern}'. Use "list" to print manifest`);
            }
        }
        switch (extendedSelection) {
            case ExtendedStackSelection.Downstream:
                includeDownstreamStacks(selectedStacks, allStacks);
                break;
            case ExtendedStackSelection.Upstream:
                includeUpstreamStacks(selectedStacks, allStacks);
                break;
        }
        // Filter original array because it is in the right order
        const selectedList = stacks.filter(s => selectedStacks.has(s.name));
        // Only check selected stacks for errors
        this.processMessages(selectedList);
        return this.applyRenames(selectedList);
    }
    /**
     * Return all stacks in the CX
     *
     * If the stacks have dependencies between them, they will be returned in
     * topologically sorted order. If there are dependencies that are not in the
     * set, they will be ignored; it is the user's responsibility that the
     * non-selected stacks have already been deployed previously.
     *
     * Renames are *NOT* applied in list mode.
     */
    async listStacks() {
        const response = await this.synthesizeStacks();
        return toposort_1.topologicalSort(response.stacks, s => s.name, s => s.dependsOn || []);
    }
    /**
     * Synthesize a single stack
     */
    async synthesizeStack(stackName) {
        const resp = await this.synthesizeStacks();
        const stack = resp.stacks.find(s => s.name === stackName);
        if (!stack) {
            throw new Error(`Stack ${stackName} not found`);
        }
        return this.applyRenames([stack])[0];
    }
    /**
     * Synthesize a set of stacks
     */
    async synthesizeStacks() {
        if (this.cachedResponse) {
            return this.cachedResponse;
        }
        const trackVersions = this.props.configuration.settings.get(['versionReporting']);
        // We may need to run the cloud executable multiple times in order to satisfy all missing context
        while (true) {
            const response = await this.props.synthesizer(this.props.aws, this.props.configuration);
            const allMissing = cdkUtil.deepMerge(...response.stacks.map(s => s.missing));
            if (!cdkUtil.isEmpty(allMissing)) {
                logging_1.debug(`Some context information is missing. Fetching...`);
                await contextproviders.provideContextValues(allMissing, this.props.configuration.context, this.props.aws);
                // Cache the new context to disk
                await this.props.configuration.saveContext();
                continue;
            }
            if (trackVersions && response.runtime) {
                const modules = formatModules(response.runtime);
                for (const stack of response.stacks) {
                    if (!stack.template.Resources) {
                        stack.template.Resources = {};
                    }
                    const resourcePresent = stack.environment.region === 'default-region'
                        || regionInfo.Fact.find(stack.environment.region, regionInfo.FactName.cdkMetadataResourceAvailable) === 'YES';
                    if (!stack.template.Resources.CDKMetadata && resourcePresent) {
                        stack.template.Resources.CDKMetadata = {
                            Type: 'AWS::CDK::Metadata',
                            Properties: {
                                Modules: modules
                            }
                        };
                    }
                    else {
                        logging_1.warning(`The stack ${stack.name} already includes a CDKMetadata resource`);
                    }
                }
            }
            // All good, return
            this.cachedResponse = response;
            return response;
            function formatModules(runtime) {
                const modules = new Array();
                // inject toolkit version to list of modules
                const toolkitVersion = require('../../../package.json').version;
                modules.push(`aws-cdk=${toolkitVersion}`);
                for (const key of Object.keys(runtime.libraries).sort()) {
                    modules.push(`${key}=${runtime.libraries[key]}`);
                }
                return modules.join(',');
            }
        }
    }
    /**
     * Extracts 'aws:cdk:warning|info|error' metadata entries from the stack synthesis
     */
    processMessages(stacks) {
        let warnings = false;
        let errors = false;
        for (const stack of stacks) {
            for (const id of Object.keys(stack.metadata)) {
                const metadata = stack.metadata[id];
                for (const entry of metadata) {
                    switch (entry.type) {
                        case cxapi.WARNING_METADATA_KEY:
                            warnings = true;
                            this.printMessage(logging_1.warning, 'Warning', id, entry);
                            break;
                        case cxapi.ERROR_METADATA_KEY:
                            errors = true;
                            this.printMessage(logging_1.error, 'Error', id, entry);
                            break;
                        case cxapi.INFO_METADATA_KEY:
                            this.printMessage(logging_1.print, 'Info', id, entry);
                            break;
                    }
                }
            }
        }
        if (errors && !this.props.ignoreErrors) {
            throw new Error('Found errors');
        }
        if (this.props.strict && warnings) {
            throw new Error('Found warnings (--strict mode)');
        }
    }
    printMessage(logFn, prefix, id, entry) {
        logFn(`[${prefix} at ${id}] ${entry.data}`);
        if (this.props.verbose) {
            logFn(`  ${entry.trace.join('\n  ')}`);
        }
    }
    applyRenames(stacks) {
        this.renames.validateSelectedStacks(stacks);
        const ret = [];
        for (const stack of stacks) {
            ret.push(Object.assign({}, stack, { originalName: stack.name, name: this.renames.finalName(stack.name) }));
        }
        return ret;
    }
}
exports.AppStacks = AppStacks;
/**
 * Combine the names of a set of stacks using a comma
 */
function listStackNames(stacks) {
    return stacks.map(s => s.name).join(', ');
}
exports.listStackNames = listStackNames;
/**
 * When selecting stacks, what other stacks to include because of dependencies
 */
var ExtendedStackSelection;
(function (ExtendedStackSelection) {
    /**
     * Don't select any extra stacks
     */
    ExtendedStackSelection[ExtendedStackSelection["None"] = 0] = "None";
    /**
     * Include stacks that this stack depends on
     */
    ExtendedStackSelection[ExtendedStackSelection["Upstream"] = 1] = "Upstream";
    /**
     * Include stacks that depend on this stack
     */
    ExtendedStackSelection[ExtendedStackSelection["Downstream"] = 2] = "Downstream";
})(ExtendedStackSelection = exports.ExtendedStackSelection || (exports.ExtendedStackSelection = {}));
/**
 * Include stacks that depend on the stacks already in the set
 *
 * Modifies `selectedStacks` in-place.
 */
function includeDownstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const [name, stack] of allStacks) {
            // Select this stack if it's not selected yet AND it depends on a stack that's in the selected set
            if (!selectedStacks.has(name) && (stack.dependsOn || []).some(dependencyName => selectedStacks.has(dependencyName))) {
                selectedStacks.set(name, stack);
                added.push(name);
                madeProgress = true;
            }
        }
    }
    if (added.length > 0) {
        logging_1.print('Including depending stacks: %s', colors.bold(added.join(', ')));
    }
}
/**
 * Include stacks that that stacks in the set depend on
 *
 * Modifies `selectedStacks` in-place.
 */
function includeUpstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const stack of selectedStacks.values()) {
            // Select an additional stack if it's not selected yet and a dependency of a selected stack (and exists, obviously)
            for (const dependencyName of (stack.dependsOn || [])) {
                if (!selectedStacks.has(dependencyName) && allStacks.has(dependencyName)) {
                    added.push(dependencyName);
                    selectedStacks.set(dependencyName, allStacks.get(dependencyName));
                    madeProgress = true;
                }
            }
        }
    }
    if (added.length > 0) {
        logging_1.print('Including dependency stacks: %s', colors.bold(added.join(', ')));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2tzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3RhY2tzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQTBDO0FBQzFDLG1EQUFvRDtBQUNwRCxzQ0FBdUM7QUFDdkMsdUNBQXdDO0FBQ3hDLDREQUE2RDtBQUM3RCwyQ0FBNkQ7QUFDN0QsMkNBQXdDO0FBRXhDLHNDQUF1QztBQUV2QywrQ0FBbUQ7QUErQ25EOzs7O0dBSUc7QUFDSCxNQUFhLFNBQVM7SUFRcEIsWUFBNkIsS0FBcUI7UUFBckIsVUFBSyxHQUFMLEtBQUssQ0FBZ0I7UUFDaEQsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxJQUFJLElBQUksaUJBQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxLQUFLLENBQUMsWUFBWSxDQUFDLFNBQW1CLEVBQUUsaUJBQXlDO1FBQ3RGLFNBQVMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsd0JBQXdCO1FBRXRFLE1BQU0sTUFBTSxHQUE2QixNQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUNqRSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztTQUNoRDtRQUVELElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDMUIsa0NBQWtDO1lBQ2xDLE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLEtBQUssS0FBSyxDQUFDLENBQUM7WUFDdEUsZUFBSyxDQUFDLG1FQUFtRSxHQUFHLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7WUFDaEgsT0FBTyxJQUFJLENBQUMs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VSxDQUFDO0lBQ2xDLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQztJQUN4QixPQUFPLFlBQVksRUFBRTtRQUNuQixZQUFZLEdBQUcsS0FBSyxDQUFDO1FBRXJCLEtBQUssTUFBTSxLQUFLLElBQUksY0FBYyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQzNDLG1IQUFtSDtZQUNuSCxLQUFLLE1BQU0sY0FBYyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQUMsRUFBRTtnQkFDcEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRTtvQkFDeEUsS0FBSyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztvQkFDM0IsY0FBYyxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUUsQ0FBQyxDQUFDO29CQUNuRSxZQUFZLEdBQUcsSUFBSSxDQUFDO2lCQUNyQjthQUNGO1NBQ0Y7S0FDRjtJQUVELElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDcEIsZUFBSyxDQUFDLGlDQUFpQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDekU7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGN4YXBpID0gcmVxdWlyZSgnQGF3cy1jZGsvY3gtYXBpJyk7XG5pbXBvcnQgcmVnaW9uSW5mbyA9IHJlcXVpcmUoJ0Bhd3MtY2RrL3JlZ2lvbi1pbmZvJyk7XG5pbXBvcnQgY29sb3JzID0gcmVxdWlyZSgnY29sb3JzL3NhZmUnKTtcbmltcG9ydCBtaW5pbWF0Y2ggPSByZXF1aXJlKCdtaW5pbWF0Y2gnKTtcbmltcG9ydCBjb250ZXh0cHJvdmlkZXJzID0gcmVxdWlyZSgnLi4vLi4vY29udGV4dC1wcm92aWRlcnMnKTtcbmltcG9ydCB7IGRlYnVnLCBlcnJvciwgcHJpbnQsIHdhcm5pbmcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IFJlbmFtZXMgfSBmcm9tICcuLi8uLi9yZW5hbWVzJztcbmltcG9ydCB7IENvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi8uLi9zZXR0aW5ncyc7XG5pbXBvcnQgY2RrVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbmltcG9ydCB7IFNESyB9IGZyb20gJy4uL3V0aWwvc2RrJztcbmltcG9ydCB7IHRvcG9sb2dpY2FsU29ydCB9IGZyb20gJy4uL3V0aWwvdG9wb3NvcnQnO1xuXG50eXBlIFN5bnRoZXNpemVyID0gKGF3czogU0RLLCBjb25maWc6IENvbmZpZ3VyYXRpb24pID0+IFByb21pc2U8Y3hhcGkuU3ludGhlc2l6ZVJlc3BvbnNlPjtcblxuZXhwb3J0IGludGVyZmFjZSBBcHBTdGFja3NQcm9wcyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGJlIHZlcmJvc2VcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHZlcmJvc2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEb24ndCBzdG9wIG9uIGVycm9yIG1ldGFkYXRhXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpZ25vcmVFcnJvcnM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUcmVhdCB3YXJuaW5ncyBpbiBtZXRhZGF0YSBhcyBlcnJvcnNcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHN0cmljdD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEFwcGxpY2F0aW9uIGNvbmZpZ3VyYXRpb24gKHNldHRpbmdzIGFuZCBjb250ZXh0KVxuICAgKi9cbiAgY29uZmlndXJhdGlvbjogQ29uZmlndXJhdGlvbjtcblxuICAvKipcbiAgICogQVdTIG9iamVjdCAodXNlZCBieSBzeW50aGVzaXplciBhbmQgY29udGV4dHByb3ZpZGVyKVxuICAgKi9cbiAgYXdzOiBTREs7XG5cbiAgLyoqXG4gICAqIFJlbmFtZXMgdG8gYXBwbHlcbiAgICovXG4gIHJlbmFtZXM/OiBSZW5hbWVzO1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBpbnZva2VkIHRvIHN5bnRoZXNpemUgdGhlIGFjdHVhbCBzdGFja3NcbiAgICovXG4gIHN5bnRoZXNpemVyOiBTeW50aGVzaXplcjtcbn1cblxuLyoqXG4gKiBSb3V0aW5lcyB0byBnZXQgc3RhY2tzIGZyb20gYW4gYXBwXG4gKlxuICogSW4gYSBjbGFzcyBiZWNhdXNlIGl0IHNoYXJlcyBzb21lIGdsb2JhbCBzdGF0ZVxuICovXG5leHBvcnQgY2xhc3MgQXBwU3RhY2tzIHtcbiAgLyoqXG4gICAqIFNpbmNlIGFwcCBleGVjdXRpb24gYmFzaWNhbGx5IGFsd2F5cyBzeW50aGVzaXplcyBhbGwgdGhlIHN0YWNrcyxcbiAgICogd2UgY2FuIGludm9rZSBpdCBvbmNlIGFuZCBjYWNoZSB0aGUgcmVzcG9uc2UgZm9yIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAqL1xuICBwcml2YXRlIGNhY2hlZFJlc3BvbnNlPzogY3hhcGkuU3ludGhlc2l6ZVJlc3BvbnNlO1xuICBwcml2YXRlIHJlYWRvbmx5IHJlbmFtZXM6IFJlbmFtZXM7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9wczogQXBwU3RhY2tzUHJvcHMpIHtcbiAgICB0aGlzLnJlbmFtZXMgPSBwcm9wcy5yZW5hbWVzIHx8IG5ldyBSZW5hbWVzKHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IGFsbCBzdGFja3MgaW4gdGhlIENYIGFuZCByZXR1cm4gdGhlIHNlbGVjdGVkIG9uZXNcbiAgICpcbiAgICogSXQncyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgbm8gc3RhY2tzIHRvIHNlbGVjdCwgb3IgaWYgb25lIG9mIHRoZSByZXF1ZXN0ZWQgcGFyYW1ldGVyc1xuICAgKiByZWZlcnMgdG8gYSBub25leGlzdGFudCBzdGFjay5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZWxlY3RTdGFja3Moc2VsZWN0b3JzOiBzdHJpbmdbXSwgZXh0ZW5kZWRTZWxlY3Rpb246IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24pOiBQcm9taXNlPFNlbGVjdGVkU3RhY2tbXT4ge1xuICAgIHNlbGVjdG9ycyA9IHNlbGVjdG9ycy5maWx0ZXIocyA9PiBzICE9IG51bGwpOyAvLyBmaWx0ZXIgbnVsbC91bmRlZmluZWRcblxuICAgIGNvbnN0IHN0YWNrczogY3hhcGkuU3ludGhlc2l6ZWRTdGFja1tdID0gYXdhaXQgdGhpcy5saXN0U3RhY2tzKCk7XG4gICAgaWYgKHN0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBhcHAgY29udGFpbnMgbm8gc3RhY2tzJyk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIHJlbW92ZSBub24tYXV0byBkZXBsb3llZCBTdGFja3NcbiAgICAgIGNvbnN0IGF1dG9EZXBsb3llZFN0YWNrcyA9IHN0YWNrcy5maWx0ZXIocyA9PiBzLmF1dG9EZXBsb3kgIT09IGZhbHNlKTtcbiAgICAgIGRlYnVnKCdTdGFjayBuYW1lIG5vdCBzcGVjaWZpZWQsIHNvIGRlZmF1bHRpbmcgdG8gYWxsIGF2YWlsYWJsZSBzdGFja3M6ICcgKyBsaXN0U3RhY2tOYW1lcyhhdXRvRGVwbG95ZWRTdGFja3MpKTtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5UmVuYW1lcyhhdXRvRGVwbG95ZWRTdGFja3MpO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbFN0YWNrcyA9IG5ldyBNYXA8c3RyaW5nLCBjeGFwaS5TeW50aGVzaXplZFN0YWNrPigpO1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBhbGxTdGFja3Muc2V0KHN0YWNrLm5hbWUsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgZXZlcnkgc2VsZWN0b3IgYXJndW1lbnQsIHBpY2sgc3RhY2tzIGZyb20gdGhlIGxpc3QuXG4gICAgY29uc3Qgc2VsZWN0ZWRTdGFja3MgPSBuZXcgTWFwPHN0cmluZywgY3hhcGkuU3ludGhlc2l6ZWRTdGFjaz4oKTtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2Ygc2VsZWN0b3JzKSB7XG4gICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgaWYgKG1pbmltYXRjaChzdGFjay5uYW1lLCBwYXR0ZXJuKSAmJiAhc2VsZWN0ZWRTdGFja3MuaGFzKHN0YWNrLm5hbWUpKSB7XG4gICAgICAgICAgc2VsZWN0ZWRTdGFja3Muc2V0KHN0YWNrLm5hbWUsIHN0YWNrKTtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YWNrIGZvdW5kIG1hdGNoaW5nICcke3BhdHRlcm59Jy4gVXNlIFwibGlzdFwiIHRvIHByaW50IG1hbmlmZXN0YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChleHRlbmRlZFNlbGVjdGlvbikge1xuICAgICAgY2FzZSBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLkRvd25zdHJlYW06XG4gICAgICAgIGluY2x1ZGVEb3duc3RyZWFtU3RhY2tzKHNlbGVjdGVkU3RhY2tzLCBhbGxTdGFja3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5VcHN0cmVhbTpcbiAgICAgICAgaW5jbHVkZVVwc3RyZWFtU3RhY2tzKHNlbGVjdGVkU3RhY2tzLCBhbGxTdGFja3MpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgb3JpZ2luYWwgYXJyYXkgYmVjYXVzZSBpdCBpcyBpbiB0aGUgcmlnaHQgb3JkZXJcbiAgICBjb25zdCBzZWxlY3RlZExpc3QgPSBzdGFja3MuZmlsdGVyKHMgPT4gc2VsZWN0ZWRTdGFja3MuaGFzKHMubmFtZSkpO1xuXG4gICAgLy8gT25seSBjaGVjayBzZWxlY3RlZCBzdGFja3MgZm9yIGVycm9yc1xuICAgIHRoaXMucHJvY2Vzc01lc3NhZ2VzKHNlbGVjdGVkTGlzdCk7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlSZW5hbWVzKHNlbGVjdGVkTGlzdCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFsbCBzdGFja3MgaW4gdGhlIENYXG4gICAqXG4gICAqIElmIHRoZSBzdGFja3MgaGF2ZSBkZXBlbmRlbmNpZXMgYmV0d2VlbiB0aGVtLCB0aGV5IHdpbGwgYmUgcmV0dXJuZWQgaW5cbiAgICogdG9wb2xvZ2ljYWxseSBzb3J0ZWQgb3JkZXIuIElmIHRoZXJlIGFyZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgbm90IGluIHRoZVxuICAgKiBzZXQsIHRoZXkgd2lsbCBiZSBpZ25vcmVkOyBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRoYXQgdGhlXG4gICAqIG5vbi1zZWxlY3RlZCBzdGFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gZGVwbG95ZWQgcHJldmlvdXNseS5cbiAgICpcbiAgICogUmVuYW1lcyBhcmUgKk5PVCogYXBwbGllZCBpbiBsaXN0IG1vZGUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdFN0YWNrcygpOiBQcm9taXNlPGN4YXBpLlN5bnRoZXNpemVkU3RhY2tbXT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zeW50aGVzaXplU3RhY2tzKCk7XG4gICAgcmV0dXJuIHRvcG9sb2dpY2FsU29ydChyZXNwb25zZS5zdGFja3MsIHMgPT4gcy5uYW1lLCBzID0+IHMuZGVwZW5kc09uIHx8IFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplIGEgc2luZ2xlIHN0YWNrXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3ludGhlc2l6ZVN0YWNrKHN0YWNrTmFtZTogc3RyaW5nKTogUHJvbWlzZTxTZWxlY3RlZFN0YWNrPiB7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuc3ludGhlc2l6ZVN0YWNrcygpO1xuICAgIGNvbnN0IHN0YWNrID0gcmVzcC5zdGFja3MuZmluZChzID0+IHMubmFtZSA9PT0gc3RhY2tOYW1lKTtcbiAgICBpZiAoIXN0YWNrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YWNrICR7c3RhY2tOYW1lfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlSZW5hbWVzKFtzdGFja10pWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bnRoZXNpemUgYSBzZXQgb2Ygc3RhY2tzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3ludGhlc2l6ZVN0YWNrcygpOiBQcm9taXNlPGN4YXBpLlN5bnRoZXNpemVSZXNwb25zZT4ge1xuICAgIGlmICh0aGlzLmNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZWRSZXNwb25zZTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFja1ZlcnNpb25zOiBib29sZWFuID0gdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ3ZlcnNpb25SZXBvcnRpbmcnXSk7XG5cbiAgICAvLyBXZSBtYXkgbmVlZCB0byBydW4gdGhlIGNsb3VkIGV4ZWN1dGFibGUgbXVsdGlwbGUgdGltZXMgaW4gb3JkZXIgdG8gc2F0aXNmeSBhbGwgbWlzc2luZyBjb250ZXh0XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBjeGFwaS5TeW50aGVzaXplUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3BzLnN5bnRoZXNpemVyKHRoaXMucHJvcHMuYXdzLCB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24pO1xuICAgICAgY29uc3QgYWxsTWlzc2luZyA9IGNka1V0aWwuZGVlcE1lcmdlKC4uLnJlc3BvbnNlLnN0YWNrcy5tYXAocyA9PiBzLm1pc3NpbmcpKTtcblxuICAgICAgaWYgKCFjZGtVdGlsLmlzRW1wdHkoYWxsTWlzc2luZykpIHtcbiAgICAgICAgZGVidWcoYFNvbWUgY29udGV4dCBpbmZvcm1hdGlvbiBpcyBtaXNzaW5nLiBGZXRjaGluZy4uLmApO1xuXG4gICAgICAgIGF3YWl0IGNvbnRleHRwcm92aWRlcnMucHJvdmlkZUNvbnRleHRWYWx1ZXMoYWxsTWlzc2luZywgdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLmNvbnRleHQsIHRoaXMucHJvcHMuYXdzKTtcblxuICAgICAgICAvLyBDYWNoZSB0aGUgbmV3IGNvbnRleHQgdG8gZGlza1xuICAgICAgICBhd2FpdCB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uc2F2ZUNvbnRleHQoKTtcblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYWNrVmVyc2lvbnMgJiYgcmVzcG9uc2UucnVudGltZSkge1xuICAgICAgICBjb25zdCBtb2R1bGVzID0gZm9ybWF0TW9kdWxlcyhyZXNwb25zZS5ydW50aW1lKTtcbiAgICAgICAgZm9yIChjb25zdCBzdGFjayBvZiByZXNwb25zZS5zdGFja3MpIHtcbiAgICAgICAgICBpZiAoIXN0YWNrLnRlbXBsYXRlLlJlc291cmNlcykge1xuICAgICAgICAgICAgc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlc291cmNlUHJlc2VudCA9IHN0YWNrLmVudmlyb25tZW50LnJlZ2lvbiA9PT0gJ2RlZmF1bHQtcmVnaW9uJ1xuICAgICAgICAgICAgfHwgcmVnaW9uSW5mby5GYWN0LmZpbmQoc3RhY2suZW52aXJvbm1lbnQucmVnaW9uLCByZWdpb25JbmZvLkZhY3ROYW1lLmNka01ldGFkYXRhUmVzb3VyY2VBdmFpbGFibGUpID09PSAnWUVTJztcbiAgICAgICAgICBpZiAoIXN0YWNrLnRlbXBsYXRlLlJlc291cmNlcy5DREtNZXRhZGF0YSAmJiByZXNvdXJjZVByZXNlbnQpIHtcbiAgICAgICAgICAgIHN0YWNrLnRlbXBsYXRlLlJlc291cmNlcy5DREtNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgVHlwZTogJ0FXUzo6Q0RLOjpNZXRhZGF0YScsXG4gICAgICAgICAgICAgIFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBNb2R1bGVzOiBtb2R1bGVzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhcm5pbmcoYFRoZSBzdGFjayAke3N0YWNrLm5hbWV9IGFscmVhZHkgaW5jbHVkZXMgYSBDREtNZXRhZGF0YSByZXNvdXJjZWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBbGwgZ29vZCwgcmV0dXJuXG4gICAgICB0aGlzLmNhY2hlZFJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGZvcm1hdE1vZHVsZXMocnVudGltZTogY3hhcGkuQXBwUnVudGltZSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IG1vZHVsZXMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgICAgIC8vIGluamVjdCB0b29sa2l0IHZlcnNpb24gdG8gbGlzdCBvZiBtb2R1bGVzXG4gICAgICAgIGNvbnN0IHRvb2xraXRWZXJzaW9uID0gcmVxdWlyZSgnLi4vLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiAgICAgICAgbW9kdWxlcy5wdXNoKGBhd3MtY2RrPSR7dG9vbGtpdFZlcnNpb259YCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocnVudGltZS5saWJyYXJpZXMpLnNvcnQoKSkge1xuICAgICAgICAgIG1vZHVsZXMucHVzaChgJHtrZXl9PSR7cnVudGltZS5saWJyYXJpZXNba2V5XX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlcy5qb2luKCcsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzICdhd3M6Y2RrOndhcm5pbmd8aW5mb3xlcnJvcicgbWV0YWRhdGEgZW50cmllcyBmcm9tIHRoZSBzdGFjayBzeW50aGVzaXNcbiAgICovXG4gIHByaXZhdGUgcHJvY2Vzc01lc3NhZ2VzKHN0YWNrczogY3hhcGkuU3ludGhlc2l6ZWRTdGFja1tdKSB7XG4gICAgbGV0IHdhcm5pbmdzID0gZmFsc2U7XG4gICAgbGV0IGVycm9ycyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKHN0YWNrLm1ldGFkYXRhKSkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHN0YWNrLm1ldGFkYXRhW2lkXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBtZXRhZGF0YSkge1xuICAgICAgICAgIHN3aXRjaCAoZW50cnkudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBjeGFwaS5XQVJOSU5HX01FVEFEQVRBX0tFWTpcbiAgICAgICAgICAgICAgd2FybmluZ3MgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLnByaW50TWVzc2FnZSh3YXJuaW5nLCAnV2FybmluZycsIGlkLCBlbnRyeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjeGFwaS5FUlJPUl9NRVRBREFUQV9LRVk6XG4gICAgICAgICAgICAgIGVycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMucHJpbnRNZXNzYWdlKGVycm9yLCAnRXJyb3InLCBpZCwgZW50cnkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY3hhcGkuSU5GT19NRVRBREFUQV9LRVk6XG4gICAgICAgICAgICAgIHRoaXMucHJpbnRNZXNzYWdlKHByaW50LCAnSW5mbycsIGlkLCBlbnRyeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnJvcnMgJiYgIXRoaXMucHJvcHMuaWdub3JlRXJyb3JzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGVycm9ycycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLnN0cmljdCAmJiB3YXJuaW5ncykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB3YXJuaW5ncyAoLS1zdHJpY3QgbW9kZSknKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByaW50TWVzc2FnZShsb2dGbjogKHM6IHN0cmluZykgPT4gdm9pZCwgcHJlZml4OiBzdHJpbmcsIGlkOiBzdHJpbmcsIGVudHJ5OiBjeGFwaS5NZXRhZGF0YUVudHJ5KSB7XG4gICAgbG9nRm4oYFske3ByZWZpeH0gYXQgJHtpZH1dICR7ZW50cnkuZGF0YX1gKTtcblxuICAgIGlmICh0aGlzLnByb3BzLnZlcmJvc2UpIHtcbiAgICAgIGxvZ0ZuKGAgICR7ZW50cnkudHJhY2Uuam9pbignXFxuICAnKX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFwcGx5UmVuYW1lcyhzdGFja3M6IGN4YXBpLlN5bnRoZXNpemVkU3RhY2tbXSk6IFNlbGVjdGVkU3RhY2tbXSB7XG4gICAgdGhpcy5yZW5hbWVzLnZhbGlkYXRlU2VsZWN0ZWRTdGFja3Moc3RhY2tzKTtcblxuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICByZXQucHVzaCh7XG4gICAgICAgIC4uLnN0YWNrLFxuICAgICAgICBvcmlnaW5hbE5hbWU6IHN0YWNrLm5hbWUsXG4gICAgICAgIG5hbWU6IHRoaXMucmVuYW1lcy5maW5hbE5hbWUoc3RhY2submFtZSksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG5cbi8qKlxuICogQ29tYmluZSB0aGUgbmFtZXMgb2YgYSBzZXQgb2Ygc3RhY2tzIHVzaW5nIGEgY29tbWFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RTdGFja05hbWVzKHN0YWNrczogY3hhcGkuU3ludGhlc2l6ZWRTdGFja1tdKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0YWNrcy5tYXAocyA9PiBzLm5hbWUpLmpvaW4oJywgJyk7XG59XG5cbi8qKlxuICogV2hlbiBzZWxlY3Rpbmcgc3RhY2tzLCB3aGF0IG90aGVyIHN0YWNrcyB0byBpbmNsdWRlIGJlY2F1c2Ugb2YgZGVwZW5kZW5jaWVzXG4gKi9cbmV4cG9ydCBlbnVtIEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24ge1xuICAvKipcbiAgICogRG9uJ3Qgc2VsZWN0IGFueSBleHRyYSBzdGFja3NcbiAgICovXG4gIE5vbmUsXG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgc3RhY2tzIHRoYXQgdGhpcyBzdGFjayBkZXBlbmRzIG9uXG4gICAqL1xuICBVcHN0cmVhbSxcblxuICAvKipcbiAgICogSW5jbHVkZSBzdGFja3MgdGhhdCBkZXBlbmQgb24gdGhpcyBzdGFja1xuICAgKi9cbiAgRG93bnN0cmVhbVxufVxuXG4vKipcbiAqIEluY2x1ZGUgc3RhY2tzIHRoYXQgZGVwZW5kIG9uIHRoZSBzdGFja3MgYWxyZWFkeSBpbiB0aGUgc2V0XG4gKlxuICogTW9kaWZpZXMgYHNlbGVjdGVkU3RhY2tzYCBpbi1wbGFjZS5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZURvd25zdHJlYW1TdGFja3Moc2VsZWN0ZWRTdGFja3M6IE1hcDxzdHJpbmcsIGN4YXBpLlN5bnRoZXNpemVkU3RhY2s+LCBhbGxTdGFja3M6IE1hcDxzdHJpbmcsIGN4YXBpLlN5bnRoZXNpemVkU3RhY2s+KSB7XG4gIGNvbnN0IGFkZGVkID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICBsZXQgbWFkZVByb2dyZXNzID0gdHJ1ZTtcbiAgd2hpbGUgKG1hZGVQcm9ncmVzcykge1xuICAgIG1hZGVQcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBbbmFtZSwgc3RhY2tdIG9mIGFsbFN0YWNrcykge1xuICAgICAgLy8gU2VsZWN0IHRoaXMgc3RhY2sgaWYgaXQncyBub3Qgc2VsZWN0ZWQgeWV0IEFORCBpdCBkZXBlbmRzIG9uIGEgc3RhY2sgdGhhdCdzIGluIHRoZSBzZWxlY3RlZCBzZXRcbiAgICAgIGlmICghc2VsZWN0ZWRTdGFja3MuaGFzKG5hbWUpICYmIChzdGFjay5kZXBlbmRzT24gfHwgW10pLnNvbWUoZGVwZW5kZW5jeU5hbWUgPT4gc2VsZWN0ZWRTdGFja3MuaGFzKGRlcGVuZGVuY3lOYW1lKSkpIHtcbiAgICAgICAgc2VsZWN0ZWRTdGFja3Muc2V0KG5hbWUsIHN0YWNrKTtcbiAgICAgICAgYWRkZWQucHVzaChuYW1lKTtcbiAgICAgICAgbWFkZVByb2dyZXNzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCkge1xuICAgIHByaW50KCdJbmNsdWRpbmcgZGVwZW5kaW5nIHN0YWNrczogJXMnLCBjb2xvcnMuYm9sZChhZGRlZC5qb2luKCcsICcpKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmNsdWRlIHN0YWNrcyB0aGF0IHRoYXQgc3RhY2tzIGluIHRoZSBzZXQgZGVwZW5kIG9uXG4gKlxuICogTW9kaWZpZXMgYHNlbGVjdGVkU3RhY2tzYCBpbi1wbGFjZS5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVVwc3RyZWFtU3RhY2tzKHNlbGVjdGVkU3RhY2tzOiBNYXA8c3RyaW5nLCBjeGFwaS5TeW50aGVzaXplZFN0YWNrPiwgYWxsU3RhY2tzOiBNYXA8c3RyaW5nLCBjeGFwaS5TeW50aGVzaXplZFN0YWNrPikge1xuICBjb25zdCBhZGRlZCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gIGxldCBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICB3aGlsZSAobWFkZVByb2dyZXNzKSB7XG4gICAgbWFkZVByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHNlbGVjdGVkU3RhY2tzLnZhbHVlcygpKSB7XG4gICAgICAvLyBTZWxlY3QgYW4gYWRkaXRpb25hbCBzdGFjayBpZiBpdCdzIG5vdCBzZWxlY3RlZCB5ZXQgYW5kIGEgZGVwZW5kZW5jeSBvZiBhIHNlbGVjdGVkIHN0YWNrIChhbmQgZXhpc3RzLCBvYnZpb3VzbHkpXG4gICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lOYW1lIG9mIChzdGFjay5kZXBlbmRzT24gfHwgW10pKSB7XG4gICAgICAgIGlmICghc2VsZWN0ZWRTdGFja3MuaGFzKGRlcGVuZGVuY3lOYW1lKSAmJiBhbGxTdGFja3MuaGFzKGRlcGVuZGVuY3lOYW1lKSkge1xuICAgICAgICAgIGFkZGVkLnB1c2goZGVwZW5kZW5jeU5hbWUpO1xuICAgICAgICAgIHNlbGVjdGVkU3RhY2tzLnNldChkZXBlbmRlbmN5TmFtZSwgYWxsU3RhY2tzLmdldChkZXBlbmRlbmN5TmFtZSkhKTtcbiAgICAgICAgICBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDApIHtcbiAgICBwcmludCgnSW5jbHVkaW5nIGRlcGVuZGVuY3kgc3RhY2tzOiAlcycsIGNvbG9ycy5ib2xkKGFkZGVkLmpvaW4oJywgJykpKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGVkU3RhY2sgZXh0ZW5kcyBjeGFwaS5TeW50aGVzaXplZFN0YWNrIHtcbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCBuYW1lIG9mIHRoZSBzdGFjayBiZWZvcmUgcmVuYW1pbmdcbiAgICovXG4gIG9yaWdpbmFsTmFtZTogc3RyaW5nO1xufVxuIl19