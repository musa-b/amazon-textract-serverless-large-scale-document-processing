"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const childProcess = require("child_process");
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const semver = require("semver");
const logging_1 = require("../../logging");
const settings_1 = require("../../settings");
/** Invokes the cloud executable and returns JSON output */
async function execProgram(aws, config) {
    const env = {};
    const context = config.context.all;
    await populateDefaultEnvironmentIfNeeded(aws, context);
    let pathMetadata = config.settings.get(['pathMetadata']);
    if (pathMetadata === undefined) {
        pathMetadata = true; // defaults to true
    }
    if (pathMetadata) {
        context[cxapi.PATH_METADATA_ENABLE_CONTEXT] = true;
    }
    let assetMetadata = config.settings.get(['assetMetadata']);
    if (assetMetadata === undefined) {
        assetMetadata = true; // defaults to true
    }
    if (assetMetadata) {
        context[cxapi.ASSET_RESOURCE_METADATA_ENABLED_CONTEXT] = true;
    }
    let versionReporting = config.settings.get(['versionReporting']);
    if (versionReporting === undefined) {
        versionReporting = true; // defaults to true
    }
    if (!versionReporting) {
        context[cxapi.DISABLE_VERSION_REPORTING] = true;
    }
    logging_1.debug('context:', context);
    env[cxapi.CONTEXT_ENV] = JSON.stringify(context);
    const app = config.settings.get(['app']);
    if (!app) {
        throw new Error(`--app is required either in command-line, in ${settings_1.PROJECT_CONFIG} or in ${settings_1.USER_DEFAULTS}`);
    }
    const commandLine = await guessExecutable(appToArray(app));
    const outdir = await fs.mkdtemp(path.join(os.tmpdir(), 'cdk'));
    logging_1.debug('outdir:', outdir);
    env[cxapi.OUTDIR_ENV] = outdir;
    try {
        const outfile = await exec();
        logging_1.debug('outfile:', outfile);
        if (!(await fs.pathExists(outfile))) {
            throw new Error(`Unable to find output file ${outfile}; are you calling app.run()?`);
        }
        const response = await fs.readJson(outfile);
        logging_1.debug(response);
        return versionCheckResponse(response);
    }
    finally {
        logging_1.debug('Removing outdir', outdir);
        await fs.remove(outdir);
    }
    async function exec() {
        return new Promise((ok, fail) => {
            // We use a slightly lower-level interface to:
            //
            // - Pass arguments in an array instead of a string, to get around a
            //   number of quoting issues introduced by the intermediate shell layer
            //   (which would be different between Linux and Windows).
            //
            // - Inherit stderr from controlling terminal. We don't use the captured value
            //   anway, and if the subprocess is printing to it for debugging purposes the
            //   user gets to see it sooner. Plus, capturing doesn't interact nicely with some
            //   processes like Maven.
            const proc = childProcess.spawn(commandLine[0], commandLine.slice(1), {
                stdio: ['ignore', 'inherit', 'inherit'],
                detached: false,
                shell: true,
                env: Object.assign({}, process.env, env)
            });
            proc.on('error', fail);
            proc.on('exit', code => {
                if (code === 0) {
                    return ok(path.join(outdir, cxapi.OUTFILE_NAME));
                }
                else {
                    return fail(new Error(`Subprocess exited with error ${code}`));
                }
            });
        });
    }
}
exports.execProgram = execProgram;
/**
 * Look at the type of response we get and upgrade it to the latest expected version
 */
function versionCheckResponse(response) {
    if (!response.version) {
        // tslint:disable-next-line:max-line-length
        throw new Error(`CDK Framework >= ${cxapi.PROTO_RESPONSE_VERSION} is required in order to interact with this version of the Toolkit.`);
    }
    const frameworkVersion = semver.coerce(response.version);
    const toolkitVersion = semver.coerce(cxapi.PROTO_RESPONSE_VERSION);
    // Should not happen, but I don't trust this library 100% either, so let's check for it to be safe
    if (!frameworkVersion || !toolkitVersion) {
        throw new Error('SemVer library could not parse versions');
    }
    if (semver.gt(frameworkVersion, toolkitVersion)) {
        throw new Error(`CDK Toolkit >= ${response.version} is required in order to interact with this program.`);
    }
    if (semver.lt(frameworkVersion, toolkitVersion)) {
        // Toolkit protocol is newer than the framework version, and we KNOW the
        // version. This is a scenario in which we could potentially do some
        // upgrading of the response in the future.
        //
        // For now though, we simply reject old responses.
        throw new Error(`CDK Framework >= ${cxapi.PROTO_RESPONSE_VERSION} is required in order to interact with this version of the Toolkit.`);
    }
    return response;
}
/**
 * If we don't have region/account defined in context, we fall back to the default SDK behavior
 * where region is retreived from ~/.aws/config and account is based on default credentials provider
 * chain and then STS is queried.
 *
 * This is done opportunistically: for example, if we can't acccess STS for some reason or the region
 * is not configured, the context value will be 'null' and there could failures down the line. In
 * some cases, synthesis does not require region/account information at all, so that might be perfectly
 * fine in certain scenarios.
 *
 * @param context The context key/value bash.
 */
async function populateDefaultEnvironmentIfNeeded(aws, context) {
    if (!(cxapi.DEFAULT_REGION_CONTEXT_KEY in context)) {
        context[cxapi.DEFAULT_REGION_CONTEXT_KEY] = await aws.defaultRegion();
        logging_1.debug(`Setting "${cxapi.DEFAULT_REGION_CONTEXT_KEY}" context to`, context[cxapi.DEFAULT_REGION_CONTEXT_KEY]);
    }
    if (!(cxapi.DEFAULT_ACCOUNT_CONTEXT_KEY in context)) {
        context[cxapi.DEFAULT_ACCOUNT_CONTEXT_KEY] = await aws.defaultAccount();
        logging_1.debug(`Setting "${cxapi.DEFAULT_ACCOUNT_CONTEXT_KEY}" context to`, context[cxapi.DEFAULT_ACCOUNT_CONTEXT_KEY]);
    }
}
/**
 * Make sure the 'app' is an array
 *
 * If it's a string, split on spaces as a trivial way of tokenizing the command line.
 */
function appToArray(app) {
    return typeof app === 'string' ? app.split(' ') : app;
}
/**
 * Direct execution of a YAML file, assume that we're deploying an Applet
 */
function executeApplet(appletFile) {
    const appletBinary = path.resolve(require.resolve('@aws-cdk/applet-js'));
    return [process.execPath, appletBinary, appletFile];
}
/**
 * Execute the given file with the same 'node' process as is running the current process
 */
function executeNode(scriptFile) {
    return [process.execPath, scriptFile];
}
/**
 * Mapping of extensions to command-line generators
 */
const EXTENSION_MAP = new Map([
    ['.yml', executeApplet],
    ['.yaml', executeApplet],
    ['.js', executeNode],
]);
/**
 * Guess the executable from the command-line argument
 *
 * Only do this if the file is NOT marked as executable. If it is,
 * we'll defer to the shebang inside the file itself.
 *
 * If we're on Windows, we ALWAYS take the handler, since it's hard to
 * verify if registry associations have or have not been set up for this
 * file type, so we'll assume the worst and take control.
 */
async function guessExecutable(commandLine) {
    if (commandLine.length === 1) {
        const fstat = await fs.stat(commandLine[0]);
        // tslint:disable-next-line:no-bitwise
        const isExecutable = (fstat.mode & fs.constants.X_OK) !== 0;
        const isWindows = process.platform === "win32";
        const handler = EXTENSION_MAP.get(path.extname(commandLine[0]));
        if (handler && (!isExecutable || isWindows)) {
            return handler(commandLine[0]);
        }
    }
    return commandLine;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImV4ZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5Q0FBMEM7QUFDMUMsOENBQStDO0FBQy9DLCtCQUFnQztBQUNoQyx5QkFBMEI7QUFDMUIsNkJBQThCO0FBQzlCLGlDQUFrQztBQUNsQywyQ0FBc0M7QUFDdEMsNkNBQThFO0FBRzlFLDJEQUEyRDtBQUNwRCxLQUFLLFVBQVUsV0FBVyxDQUFDLEdBQVEsRUFBRSxNQUFxQjtJQUMvRCxNQUFNLEdBQUcsR0FBOEIsRUFBRyxDQUFDO0lBRTNDLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO0lBQ25DLE1BQU0sa0NBQWtDLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXZELElBQUksWUFBWSxHQUFZLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztJQUNsRSxJQUFJLFlBQVksS0FBSyxTQUFTLEVBQUU7UUFDNUIsWUFBWSxHQUFHLElBQUksQ0FBQyxDQUFDLG1CQUFtQjtLQUMzQztJQUVELElBQUksWUFBWSxFQUFFO1FBQ2hCLE9BQU8sQ0FBQyxLQUFLLENBQUMsNEJBQTRCLENBQUMsR0FBRyxJQUFJLENBQUM7S0FDcEQ7SUFFRCxJQUFJLGFBQWEsR0FBWSxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7SUFDcEUsSUFBSSxhQUFhLEtBQUssU0FBUyxFQUFFO1FBQy9CLGFBQWEsR0FBRyxJQUFJLENBQUMsQ0FBQyxtQkFBbUI7S0FDMUM7SUFFRCxJQUFJLGFBQWEsRUFBRTtRQUNqQixPQUFPLENBQUMsS0FBSyxDQUFDLHVDQUF1QyxDQUFDLEdBQUcsSUFBSSxDQUFDO0tBQy9EO0lBRUQsSUFBSSxnQkFBZ0IsR0FBWSxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGtC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IHJlcXVpcmUoJ0Bhd3MtY2RrL2N4LWFwaScpO1xuaW1wb3J0IGNoaWxkUHJvY2VzcyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcbmltcG9ydCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XG5pbXBvcnQgb3MgPSByZXF1aXJlKCdvcycpO1xuaW1wb3J0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5pbXBvcnQgc2VtdmVyID0gcmVxdWlyZSgnc2VtdmVyJyk7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgQ29uZmlndXJhdGlvbiwgUFJPSkVDVF9DT05GSUcsIFVTRVJfREVGQVVMVFMgfSBmcm9tICcuLi8uLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyBTREsgfSBmcm9tICcuLi91dGlsL3Nkayc7XG5cbi8qKiBJbnZva2VzIHRoZSBjbG91ZCBleGVjdXRhYmxlIGFuZCByZXR1cm5zIEpTT04gb3V0cHV0ICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY1Byb2dyYW0oYXdzOiBTREssIGNvbmZpZzogQ29uZmlndXJhdGlvbik6IFByb21pc2U8Y3hhcGkuU3ludGhlc2l6ZVJlc3BvbnNlPiB7XG4gIGNvbnN0IGVudjogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHsgfTtcblxuICBjb25zdCBjb250ZXh0ID0gY29uZmlnLmNvbnRleHQuYWxsO1xuICBhd2FpdCBwb3B1bGF0ZURlZmF1bHRFbnZpcm9ubWVudElmTmVlZGVkKGF3cywgY29udGV4dCk7XG5cbiAgbGV0IHBhdGhNZXRhZGF0YTogYm9vbGVhbiA9IGNvbmZpZy5zZXR0aW5ncy5nZXQoWydwYXRoTWV0YWRhdGEnXSk7XG4gIGlmIChwYXRoTWV0YWRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGF0aE1ldGFkYXRhID0gdHJ1ZTsgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICB9XG5cbiAgaWYgKHBhdGhNZXRhZGF0YSkge1xuICAgIGNvbnRleHRbY3hhcGkuUEFUSF9NRVRBREFUQV9FTkFCTEVfQ09OVEVYVF0gPSB0cnVlO1xuICB9XG5cbiAgbGV0IGFzc2V0TWV0YWRhdGE6IGJvb2xlYW4gPSBjb25maWcuc2V0dGluZ3MuZ2V0KFsnYXNzZXRNZXRhZGF0YSddKTtcbiAgaWYgKGFzc2V0TWV0YWRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2V0TWV0YWRhdGEgPSB0cnVlOyAvLyBkZWZhdWx0cyB0byB0cnVlXG4gIH1cblxuICBpZiAoYXNzZXRNZXRhZGF0YSkge1xuICAgIGNvbnRleHRbY3hhcGkuQVNTRVRfUkVTT1VSQ0VfTUVUQURBVEFfRU5BQkxFRF9DT05URVhUXSA9IHRydWU7XG4gIH1cblxuICBsZXQgdmVyc2lvblJlcG9ydGluZzogYm9vbGVhbiA9IGNvbmZpZy5zZXR0aW5ncy5nZXQoWyd2ZXJzaW9uUmVwb3J0aW5nJ10pO1xuICBpZiAodmVyc2lvblJlcG9ydGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmVyc2lvblJlcG9ydGluZyA9IHRydWU7IC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgfVxuXG4gIGlmICghdmVyc2lvblJlcG9ydGluZykge1xuICAgIGNvbnRleHRbY3hhcGkuRElTQUJMRV9WRVJTSU9OX1JFUE9SVElOR10gPSB0cnVlO1xuICB9XG5cbiAgZGVidWcoJ2NvbnRleHQ6JywgY29udGV4dCk7XG5cbiAgZW52W2N4YXBpLkNPTlRFWFRfRU5WXSA9IEpTT04uc3RyaW5naWZ5KGNvbnRleHQpO1xuXG4gIGNvbnN0IGFwcCA9IGNvbmZpZy5zZXR0aW5ncy5nZXQoWydhcHAnXSk7XG4gIGlmICghYXBwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAtLWFwcCBpcyByZXF1aXJlZCBlaXRoZXIgaW4gY29tbWFuZC1saW5lLCBpbiAke1BST0pFQ1RfQ09ORklHfSBvciBpbiAke1VTRVJfREVGQVVMVFN9YCk7XG4gIH1cblxuICBjb25zdCBjb21tYW5kTGluZSA9IGF3YWl0IGd1ZXNzRXhlY3V0YWJsZShhcHBUb0FycmF5KGFwcCkpO1xuXG4gIGNvbnN0IG91dGRpciA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCAnY2RrJykpO1xuICBkZWJ1Zygnb3V0ZGlyOicsIG91dGRpcik7XG4gIGVudltjeGFwaS5PVVRESVJfRU5WXSA9IG91dGRpcjtcblxuICB0cnkge1xuICAgIGNvbnN0IG91dGZpbGUgPSBhd2FpdCBleGVjKCk7XG4gICAgZGVidWcoJ291dGZpbGU6Jywgb3V0ZmlsZSk7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhvdXRmaWxlKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgb3V0cHV0IGZpbGUgJHtvdXRmaWxlfTsgYXJlIHlvdSBjYWxsaW5nIGFwcC5ydW4oKT9gKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZzLnJlYWRKc29uKG91dGZpbGUpO1xuICAgIGRlYnVnKHJlc3BvbnNlKTtcbiAgICByZXR1cm4gdmVyc2lvbkNoZWNrUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9IGZpbmFsbHkge1xuICAgIGRlYnVnKCdSZW1vdmluZyBvdXRkaXInLCBvdXRkaXIpO1xuICAgIGF3YWl0IGZzLnJlbW92ZShvdXRkaXIpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gZXhlYygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPigob2ssIGZhaWwpID0+IHtcbiAgICAgIC8vIFdlIHVzZSBhIHNsaWdodGx5IGxvd2VyLWxldmVsIGludGVyZmFjZSB0bzpcbiAgICAgIC8vXG4gICAgICAvLyAtIFBhc3MgYXJndW1lbnRzIGluIGFuIGFycmF5IGluc3RlYWQgb2YgYSBzdHJpbmcsIHRvIGdldCBhcm91bmQgYVxuICAgICAgLy8gICBudW1iZXIgb2YgcXVvdGluZyBpc3N1ZXMgaW50cm9kdWNlZCBieSB0aGUgaW50ZXJtZWRpYXRlIHNoZWxsIGxheWVyXG4gICAgICAvLyAgICh3aGljaCB3b3VsZCBiZSBkaWZmZXJlbnQgYmV0d2VlbiBMaW51eCBhbmQgV2luZG93cykuXG4gICAgICAvL1xuICAgICAgLy8gLSBJbmhlcml0IHN0ZGVyciBmcm9tIGNvbnRyb2xsaW5nIHRlcm1pbmFsLiBXZSBkb24ndCB1c2UgdGhlIGNhcHR1cmVkIHZhbHVlXG4gICAgICAvLyAgIGFud2F5LCBhbmQgaWYgdGhlIHN1YnByb2Nlc3MgaXMgcHJpbnRpbmcgdG8gaXQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyB0aGVcbiAgICAgIC8vICAgdXNlciBnZXRzIHRvIHNlZSBpdCBzb29uZXIuIFBsdXMsIGNhcHR1cmluZyBkb2Vzbid0IGludGVyYWN0IG5pY2VseSB3aXRoIHNvbWVcbiAgICAgIC8vICAgcHJvY2Vzc2VzIGxpa2UgTWF2ZW4uXG4gICAgICBjb25zdCBwcm9jID0gY2hpbGRQcm9jZXNzLnNwYXduKGNvbW1hbmRMaW5lWzBdLCBjb21tYW5kTGluZS5zbGljZSgxKSwge1xuICAgICAgICBzdGRpbzogWydpZ25vcmUnLCAnaW5oZXJpdCcsICdpbmhlcml0J10sXG4gICAgICAgIGRldGFjaGVkOiBmYWxzZSxcbiAgICAgICAgc2hlbGw6IHRydWUsXG4gICAgICAgIGVudjoge1xuICAgICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAgIC4uLmVudlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcHJvYy5vbignZXJyb3InLCBmYWlsKTtcblxuICAgICAgcHJvYy5vbignZXhpdCcsIGNvZGUgPT4ge1xuICAgICAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBvayhwYXRoLmpvaW4ob3V0ZGlyLCBjeGFwaS5PVVRGSUxFX05BTUUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFpbChuZXcgRXJyb3IoYFN1YnByb2Nlc3MgZXhpdGVkIHdpdGggZXJyb3IgJHtjb2RlfWApKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBMb29rIGF0IHRoZSB0eXBlIG9mIHJlc3BvbnNlIHdlIGdldCBhbmQgdXBncmFkZSBpdCB0byB0aGUgbGF0ZXN0IGV4cGVjdGVkIHZlcnNpb25cbiAqL1xuZnVuY3Rpb24gdmVyc2lvbkNoZWNrUmVzcG9uc2UocmVzcG9uc2U6IGN4YXBpLlN5bnRoZXNpemVSZXNwb25zZSk6IGN4YXBpLlN5bnRoZXNpemVSZXNwb25zZSB7XG4gIGlmICghcmVzcG9uc2UudmVyc2lvbikge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENESyBGcmFtZXdvcmsgPj0gJHtjeGFwaS5QUk9UT19SRVNQT05TRV9WRVJTSU9OfSBpcyByZXF1aXJlZCBpbiBvcmRlciB0byBpbnRlcmFjdCB3aXRoIHRoaXMgdmVyc2lvbiBvZiB0aGUgVG9vbGtpdC5gKTtcbiAgfVxuXG4gIGNvbnN0IGZyYW1ld29ya1ZlcnNpb24gPSBzZW12ZXIuY29lcmNlKHJlc3BvbnNlLnZlcnNpb24pO1xuICBjb25zdCB0b29sa2l0VmVyc2lvbiA9IHNlbXZlci5jb2VyY2UoY3hhcGkuUFJPVE9fUkVTUE9OU0VfVkVSU0lPTik7XG5cbiAgLy8gU2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCBJIGRvbid0IHRydXN0IHRoaXMgbGlicmFyeSAxMDAlIGVpdGhlciwgc28gbGV0J3MgY2hlY2sgZm9yIGl0IHRvIGJlIHNhZmVcbiAgaWYgKCFmcmFtZXdvcmtWZXJzaW9uIHx8ICF0b29sa2l0VmVyc2lvbikgeyB0aHJvdyBuZXcgRXJyb3IoJ1NlbVZlciBsaWJyYXJ5IGNvdWxkIG5vdCBwYXJzZSB2ZXJzaW9ucycpOyB9XG5cbiAgaWYgKHNlbXZlci5ndChmcmFtZXdvcmtWZXJzaW9uLCB0b29sa2l0VmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENESyBUb29sa2l0ID49ICR7cmVzcG9uc2UudmVyc2lvbn0gaXMgcmVxdWlyZWQgaW4gb3JkZXIgdG8gaW50ZXJhY3Qgd2l0aCB0aGlzIHByb2dyYW0uYCk7XG4gIH1cblxuICBpZiAoc2VtdmVyLmx0KGZyYW1ld29ya1ZlcnNpb24sIHRvb2xraXRWZXJzaW9uKSkge1xuICAgIC8vIFRvb2xraXQgcHJvdG9jb2wgaXMgbmV3ZXIgdGhhbiB0aGUgZnJhbWV3b3JrIHZlcnNpb24sIGFuZCB3ZSBLTk9XIHRoZVxuICAgIC8vIHZlcnNpb24uIFRoaXMgaXMgYSBzY2VuYXJpbyBpbiB3aGljaCB3ZSBjb3VsZCBwb3RlbnRpYWxseSBkbyBzb21lXG4gICAgLy8gdXBncmFkaW5nIG9mIHRoZSByZXNwb25zZSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vXG4gICAgLy8gRm9yIG5vdyB0aG91Z2gsIHdlIHNpbXBseSByZWplY3Qgb2xkIHJlc3BvbnNlcy5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENESyBGcmFtZXdvcmsgPj0gJHtjeGFwaS5QUk9UT19SRVNQT05TRV9WRVJTSU9OfSBpcyByZXF1aXJlZCBpbiBvcmRlciB0byBpbnRlcmFjdCB3aXRoIHRoaXMgdmVyc2lvbiBvZiB0aGUgVG9vbGtpdC5gKTtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuLyoqXG4gKiBJZiB3ZSBkb24ndCBoYXZlIHJlZ2lvbi9hY2NvdW50IGRlZmluZWQgaW4gY29udGV4dCwgd2UgZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IFNESyBiZWhhdmlvclxuICogd2hlcmUgcmVnaW9uIGlzIHJldHJlaXZlZCBmcm9tIH4vLmF3cy9jb25maWcgYW5kIGFjY291bnQgaXMgYmFzZWQgb24gZGVmYXVsdCBjcmVkZW50aWFscyBwcm92aWRlclxuICogY2hhaW4gYW5kIHRoZW4gU1RTIGlzIHF1ZXJpZWQuXG4gKlxuICogVGhpcyBpcyBkb25lIG9wcG9ydHVuaXN0aWNhbGx5OiBmb3IgZXhhbXBsZSwgaWYgd2UgY2FuJ3QgYWNjY2VzcyBTVFMgZm9yIHNvbWUgcmVhc29uIG9yIHRoZSByZWdpb25cbiAqIGlzIG5vdCBjb25maWd1cmVkLCB0aGUgY29udGV4dCB2YWx1ZSB3aWxsIGJlICdudWxsJyBhbmQgdGhlcmUgY291bGQgZmFpbHVyZXMgZG93biB0aGUgbGluZS4gSW5cbiAqIHNvbWUgY2FzZXMsIHN5bnRoZXNpcyBkb2VzIG5vdCByZXF1aXJlIHJlZ2lvbi9hY2NvdW50IGluZm9ybWF0aW9uIGF0IGFsbCwgc28gdGhhdCBtaWdodCBiZSBwZXJmZWN0bHlcbiAqIGZpbmUgaW4gY2VydGFpbiBzY2VuYXJpb3MuXG4gKlxuICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQga2V5L3ZhbHVlIGJhc2guXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBvcHVsYXRlRGVmYXVsdEVudmlyb25tZW50SWZOZWVkZWQoYXdzOiBTREssIGNvbnRleHQ6IGFueSkge1xuICBpZiAoIShjeGFwaS5ERUZBVUxUX1JFR0lPTl9DT05URVhUX0tFWSBpbiBjb250ZXh0KSkge1xuICAgIGNvbnRleHRbY3hhcGkuREVGQVVMVF9SRUdJT05fQ09OVEVYVF9LRVldID0gYXdhaXQgYXdzLmRlZmF1bHRSZWdpb24oKTtcbiAgICBkZWJ1ZyhgU2V0dGluZyBcIiR7Y3hhcGkuREVGQVVMVF9SRUdJT05fQ09OVEVYVF9LRVl9XCIgY29udGV4dCB0b2AsIGNvbnRleHRbY3hhcGkuREVGQVVMVF9SRUdJT05fQ09OVEVYVF9LRVldKTtcbiAgfVxuXG4gIGlmICghKGN4YXBpLkRFRkFVTFRfQUNDT1VOVF9DT05URVhUX0tFWSBpbiBjb250ZXh0KSkge1xuICAgIGNvbnRleHRbY3hhcGkuREVGQVVMVF9BQ0NPVU5UX0NPTlRFWFRfS0VZXSA9IGF3YWl0IGF3cy5kZWZhdWx0QWNjb3VudCgpO1xuICAgIGRlYnVnKGBTZXR0aW5nIFwiJHtjeGFwaS5ERUZBVUxUX0FDQ09VTlRfQ09OVEVYVF9LRVl9XCIgY29udGV4dCB0b2AsIGNvbnRleHRbY3hhcGkuREVGQVVMVF9BQ0NPVU5UX0NPTlRFWFRfS0VZXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhlICdhcHAnIGlzIGFuIGFycmF5XG4gKlxuICogSWYgaXQncyBhIHN0cmluZywgc3BsaXQgb24gc3BhY2VzIGFzIGEgdHJpdmlhbCB3YXkgb2YgdG9rZW5pemluZyB0aGUgY29tbWFuZCBsaW5lLlxuICovXG5mdW5jdGlvbiBhcHBUb0FycmF5KGFwcDogYW55KSB7XG4gIHJldHVybiB0eXBlb2YgYXBwID09PSAnc3RyaW5nJyA/IGFwcC5zcGxpdCgnICcpIDogYXBwO1xufVxuXG50eXBlIENvbW1hbmRHZW5lcmF0b3IgPSAoZmlsZTogc3RyaW5nKSA9PiBzdHJpbmdbXTtcblxuLyoqXG4gKiBEaXJlY3QgZXhlY3V0aW9uIG9mIGEgWUFNTCBmaWxlLCBhc3N1bWUgdGhhdCB3ZSdyZSBkZXBsb3lpbmcgYW4gQXBwbGV0XG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVBcHBsZXQoYXBwbGV0RmlsZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGFwcGxldEJpbmFyeSA9IHBhdGgucmVzb2x2ZShyZXF1aXJlLnJlc29sdmUoJ0Bhd3MtY2RrL2FwcGxldC1qcycpKTtcbiAgICByZXR1cm4gW3Byb2Nlc3MuZXhlY1BhdGgsIGFwcGxldEJpbmFyeSwgYXBwbGV0RmlsZV07XG59XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gZmlsZSB3aXRoIHRoZSBzYW1lICdub2RlJyBwcm9jZXNzIGFzIGlzIHJ1bm5pbmcgdGhlIGN1cnJlbnQgcHJvY2Vzc1xuICovXG5mdW5jdGlvbiBleGVjdXRlTm9kZShzY3JpcHRGaWxlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFtwcm9jZXNzLmV4ZWNQYXRoLCBzY3JpcHRGaWxlXTtcbn1cblxuLyoqXG4gKiBNYXBwaW5nIG9mIGV4dGVuc2lvbnMgdG8gY29tbWFuZC1saW5lIGdlbmVyYXRvcnNcbiAqL1xuY29uc3QgRVhURU5TSU9OX01BUCA9IG5ldyBNYXA8c3RyaW5nLCBDb21tYW5kR2VuZXJhdG9yPihbXG4gIFsnLnltbCcsIGV4ZWN1dGVBcHBsZXRdLFxuICBbJy55YW1sJywgZXhlY3V0ZUFwcGxldF0sXG4gIFsnLmpzJywgZXhlY3V0ZU5vZGVdLFxuXSk7XG5cbi8qKlxuICogR3Vlc3MgdGhlIGV4ZWN1dGFibGUgZnJvbSB0aGUgY29tbWFuZC1saW5lIGFyZ3VtZW50XG4gKlxuICogT25seSBkbyB0aGlzIGlmIHRoZSBmaWxlIGlzIE5PVCBtYXJrZWQgYXMgZXhlY3V0YWJsZS4gSWYgaXQgaXMsXG4gKiB3ZSdsbCBkZWZlciB0byB0aGUgc2hlYmFuZyBpbnNpZGUgdGhlIGZpbGUgaXRzZWxmLlxuICpcbiAqIElmIHdlJ3JlIG9uIFdpbmRvd3MsIHdlIEFMV0FZUyB0YWtlIHRoZSBoYW5kbGVyLCBzaW5jZSBpdCdzIGhhcmQgdG9cbiAqIHZlcmlmeSBpZiByZWdpc3RyeSBhc3NvY2lhdGlvbnMgaGF2ZSBvciBoYXZlIG5vdCBiZWVuIHNldCB1cCBmb3IgdGhpc1xuICogZmlsZSB0eXBlLCBzbyB3ZSdsbCBhc3N1bWUgdGhlIHdvcnN0IGFuZCB0YWtlIGNvbnRyb2wuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGd1ZXNzRXhlY3V0YWJsZShjb21tYW5kTGluZTogc3RyaW5nW10pIHtcbiAgaWYgKGNvbW1hbmRMaW5lLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGZzdGF0ID0gYXdhaXQgZnMuc3RhdChjb21tYW5kTGluZVswXSk7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICBjb25zdCBpc0V4ZWN1dGFibGUgPSAoZnN0YXQubW9kZSAmIGZzLmNvbnN0YW50cy5YX09LKSAhPT0gMDtcbiAgICBjb25zdCBpc1dpbmRvd3MgPSBwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCI7XG5cbiAgICBjb25zdCBoYW5kbGVyID0gRVhURU5TSU9OX01BUC5nZXQocGF0aC5leHRuYW1lKGNvbW1hbmRMaW5lWzBdKSk7XG4gICAgaWYgKGhhbmRsZXIgJiYgKCFpc0V4ZWN1dGFibGUgfHwgaXNXaW5kb3dzKSkge1xuICAgICAgcmV0dXJuIGhhbmRsZXIoY29tbWFuZExpbmVbMF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tbWFuZExpbmU7XG59XG4iXX0=